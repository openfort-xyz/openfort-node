/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Openfort API
 * Complete Openfort API references and guides can be found at: https://www.openfort.io/docs
 * OpenAPI spec version: 1.0.0
 */
export type JsonRpcSuccessResponseAnyJsonrpc = typeof JsonRpcSuccessResponseAnyJsonrpc[keyof typeof JsonRpcSuccessResponseAnyJsonrpc];


export const JsonRpcSuccessResponseAnyJsonrpc = {
  '20': '2.0',
} as const;

/**
 * JSON-RPC 2.0 Success Response
 */
export interface JsonRpcSuccessResponseAny {
  jsonrpc: JsonRpcSuccessResponseAnyJsonrpc;
  result: unknown;
  id: string | number | null;
}

/**
 * JSON-RPC 2.0 Error Object
 */
export interface JsonRpcError {
  code: number;
  message: string;
  data?: unknown;
}

export type JsonRpcErrorResponseJsonrpc = typeof JsonRpcErrorResponseJsonrpc[keyof typeof JsonRpcErrorResponseJsonrpc];


export const JsonRpcErrorResponseJsonrpc = {
  '20': '2.0',
} as const;

/**
 * JSON-RPC 2.0 Error Response
 */
export interface JsonRpcErrorResponse {
  jsonrpc: JsonRpcErrorResponseJsonrpc;
  error: JsonRpcError;
  id: string | number | null;
}

/**
 * JSON-RPC 2.0 Response (either success or error)
 */
export type JsonRpcResponse = JsonRpcSuccessResponseAny | JsonRpcErrorResponse;

export type JsonRpcRequestJsonrpc = typeof JsonRpcRequestJsonrpc[keyof typeof JsonRpcRequestJsonrpc];


export const JsonRpcRequestJsonrpc = {
  '20': '2.0',
} as const;

/**
 * JSON-RPC 2.0 Request
 */
export interface JsonRpcRequest {
  jsonrpc: JsonRpcRequestJsonrpc;
  method: string;
  params?: unknown;
  id?: string | number | null;
}

export interface CheckoutResponse {
  url: string;
}

export type Currency = typeof Currency[keyof typeof Currency];


export const Currency = {
  usd: 'usd',
} as const;

export interface CheckoutRequest {
  /**
   * Amount in cents
   * @minimum 1
   */
  amount: number;
  currency: Currency;
  cancelUrl?: string;
  successUrl?: string;
}

export interface CheckoutSubscriptionRequest {
  plan: string;
  cancelUrl?: string;
  successUrl?: string;
}

export interface Money {
  /**
   * Amount in cents
   * @minimum 1
   */
  amount: number;
  currency: Currency;
}

export interface BalanceResponse {
  balance: Money;
  expenses: Money;
  payments: Money;
}

export type ResponseTypeLIST = typeof ResponseTypeLIST[keyof typeof ResponseTypeLIST];


export const ResponseTypeLIST = {
  list: 'list',
} as const;

export interface EntityIdResponse {
  id: string;
}

export type SponsorSchemaPAYFORUSER = typeof SponsorSchemaPAYFORUSER[keyof typeof SponsorSchemaPAYFORUSER];


export const SponsorSchemaPAYFORUSER = {
  pay_for_user: 'pay_for_user',
} as const;

export type SponsorSchema = typeof SponsorSchema[keyof typeof SponsorSchema];


export const SponsorSchema = {
  pay_for_user: 'pay_for_user',
  charge_custom_tokens: 'charge_custom_tokens',
  fixed_rate: 'fixed_rate',
} as const;

export interface PayForUserPolicyStrategy {
  sponsorSchema: SponsorSchemaPAYFORUSER;
  /** @nullable */
  depositor?: string | null;
}

export type SponsorSchemaCHARGECUSTOMTOKENS = typeof SponsorSchemaCHARGECUSTOMTOKENS[keyof typeof SponsorSchemaCHARGECUSTOMTOKENS];


export const SponsorSchemaCHARGECUSTOMTOKENS = {
  charge_custom_tokens: 'charge_custom_tokens',
} as const;

export interface ChargeCustomTokenPolicyStrategy {
  sponsorSchema: SponsorSchemaCHARGECUSTOMTOKENS;
  /** @nullable */
  depositor?: string | null;
  tokenContract: string;
  tokenContractAmount: string;
}

export type SponsorSchemaFIXEDRATE = typeof SponsorSchemaFIXEDRATE[keyof typeof SponsorSchemaFIXEDRATE];


export const SponsorSchemaFIXEDRATE = {
  fixed_rate: 'fixed_rate',
} as const;

export interface FixedRateTokenPolicyStrategy {
  sponsorSchema: SponsorSchemaFIXEDRATE;
  /** @nullable */
  depositor?: string | null;
  tokenContract: string;
  tokenContractAmount: string;
}

export type PolicyStrategy = PayForUserPolicyStrategy | ChargeCustomTokenPolicyStrategy | FixedRateTokenPolicyStrategy;

export type EntityTypePOLICY = typeof EntityTypePOLICY[keyof typeof EntityTypePOLICY];


export const EntityTypePOLICY = {
  policy: 'policy',
} as const;

export interface Policy {
  id: string;
  object: EntityTypePOLICY;
  createdAt: number;
  /** @nullable */
  name: string | null;
  deleted: boolean;
  enabled: boolean;
  /** The chain ID. */
  chainId: number;
  paymaster?: EntityIdResponse;
  forwarderContract?: EntityIdResponse;
  strategy: PolicyStrategy;
  transactionIntents: EntityIdResponse[];
  policyRules: EntityIdResponse[];
}

export interface PlayerMetadata {[key: string]: string | number}

export type EntityTypePLAYER = typeof EntityTypePLAYER[keyof typeof EntityTypePLAYER];


export const EntityTypePLAYER = {
  player: 'player',
} as const;

export interface Player {
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  name: string;
  description?: string;
  metadata?: PlayerMetadata;
  transactionIntents?: EntityIdResponse[];
  accounts?: EntityIdResponse[];
}

export type EntityTypeACCOUNT = typeof EntityTypeACCOUNT[keyof typeof EntityTypeACCOUNT];


export const EntityTypeACCOUNT = {
  account: 'account',
} as const;

export interface Account {
  id: string;
  object: EntityTypeACCOUNT;
  createdAt: number;
  address: string;
  ownerAddress: string;
  deployed: boolean;
  custodial: boolean;
  embeddedSigner: boolean;
  /** The chain ID. */
  chainId: number;
  accountType: string;
  pendingOwnerAddress?: string;
  transactionIntents?: EntityIdResponse[];
  player: EntityIdResponse;
}

export type EntityTypeDEVELOPERACCOUNT = typeof EntityTypeDEVELOPERACCOUNT[keyof typeof EntityTypeDEVELOPERACCOUNT];


export const EntityTypeDEVELOPERACCOUNT = {
  developerAccount: 'developerAccount',
} as const;

export interface DeveloperAccount {
  id: string;
  object: EntityTypeDEVELOPERACCOUNT;
  createdAt: number;
  address: string;
  custodial: boolean;
  name?: string;
  transactionIntents?: EntityIdResponse[];
}

export type TransactionAbstractionType = typeof TransactionAbstractionType[keyof typeof TransactionAbstractionType];


export const TransactionAbstractionType = {
  accountAbstractionV6: 'accountAbstractionV6',
  accountAbstractionV8: 'accountAbstractionV8',
  accountAbstractionV9: 'accountAbstractionV9',
  zkSync: 'zkSync',
  standard: 'standard',
} as const;

export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];


export const TransactionStatus = {
  none: 'none',
  new: 'new',
  sent: 'sent',
  dropped: 'dropped',
  indexed: 'indexed',
  confirmed: 'confirmed',
  reverted: 'reverted',
  notfound: 'notfound',
  replaced: 'replaced',
  expired: 'expired',
} as const;

/**
 * A transition represents a change in the status of a transaction intent.
 */
export interface Transition {
  fromStatus: TransactionStatus;
  toStatus: TransactionStatus;
  at: number;
}

export interface ZKSyncDetails {
  /** The transaction sender. */
  from: string;
  /** The transaction recipient or contract address. */
  to: string;
  /** A contract hashed method call with encoded args. */
  data?: string;
  /** Unique number identifying this transaction. */
  nonce: string;
  /** The gas limit for the transaction. */
  gas: string;
  /** Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to EIP-1559 Transactions. */
  maxFeePerGas: string;
  /** Max priority fee per gas (in wei). Only applies to EIP-1559 Transactions. */
  maxPriorityFeePerGas: string;
  /** Address of the paymaster account that will pay the fees. */
  paymaster?: string;
  /** Input data to the paymaster */
  paymasterInput?: string;
  /** Value in wei sent with this transaction. */
  value?: string;
}

export interface UserOperationV6 {
  /** The data to pass to the `sender` during the main execution call. */
  callData: string;
  /** The amount of gas to allocate the main execution call */
  callGasLimit: string;
  /** Account init code. Only for new accounts. */
  initCode?: string;
  /** Maximum fee per gas. */
  maxFeePerGas: string;
  /** Maximum priority fee per gas. */
  maxPriorityFeePerGas: string;
  /** Anti-replay parameter. */
  nonce: string;
  /** Paymaster address with calldata. */
  paymasterAndData?: string;
  /** Extra gas to pay the bundler. */
  preVerificationGas: string;
  /** The account making the operation. */
  sender: string;
  /** Data passed into the account to verify authorization. */
  signature: string;
  /** The amount of gas to allocate for the verification step. */
  verificationGasLimit: string;
}

export interface AccountAbstractionV6Details {
  userOperation: UserOperationV6;
  /** A User Operation hash. */
  userOperationHash: string;
}

export interface UserOperationV8 {
  /** The data to pass to the `sender` during the main execution call. */
  callData: string;
  /** The amount of gas to allocate the main execution call */
  callGasLimit: string;
  /** Account init code. Only for new accounts. */
  factory?: string;
  /** Factory data for account creation. */
  factoryData?: string;
  /** Maximum fee per gas. */
  maxFeePerGas: string;
  /** Maximum priority fee per gas. */
  maxPriorityFeePerGas: string;
  /** Anti-replay parameter. */
  nonce: string;
  /** Paymaster address. */
  paymaster?: string;
  /** Paymaster verification gas limit. */
  paymasterVerificationGasLimit?: string;
  /** Paymaster post-operation gas limit. */
  paymasterPostOpGasLimit?: string;
  /** Paymaster data. */
  paymasterData?: string;
  /** Extra gas to pay the bundler. */
  preVerificationGas: string;
  /** The account making the operation. */
  sender: string;
  /** Data passed into the account to verify authorization. */
  signature: string;
  /** The amount of gas to allocate for the verification step. */
  verificationGasLimit: string;
}

export interface AccountAbstractionV8Details {
  userOperation: UserOperationV8;
  /** A User Operation hash. */
  userOperationHash: string;
}

/**
 * V9 UserOperation extends V8 with paymasterSignature field.
paymasterSignature enables parallelizable Paymaster signing -
data can be passed to the Paymaster after the UserOperation is signed by the wallet.
 */
export interface UserOperationV9 {
  /** The data to pass to the `sender` during the main execution call. */
  callData: string;
  /** The amount of gas to allocate the main execution call */
  callGasLimit: string;
  /** Account init code. Only for new accounts. */
  factory?: string;
  /** Factory data for account creation. */
  factoryData?: string;
  /** Maximum fee per gas. */
  maxFeePerGas: string;
  /** Maximum priority fee per gas. */
  maxPriorityFeePerGas: string;
  /** Anti-replay parameter. */
  nonce: string;
  /** Paymaster address. */
  paymaster?: string;
  /** Paymaster verification gas limit. */
  paymasterVerificationGasLimit?: string;
  /** Paymaster post-operation gas limit. */
  paymasterPostOpGasLimit?: string;
  /** Paymaster data. */
  paymasterData?: string;
  /** Extra gas to pay the bundler. */
  preVerificationGas: string;
  /** The account making the operation. */
  sender: string;
  /** Data passed into the account to verify authorization. */
  signature: string;
  /** The amount of gas to allocate for the verification step. */
  verificationGasLimit: string;
  /** Paymaster signature - enables parallelizable signing.
This field does not affect the UserOperation hash, allowing
the sender and paymaster to sign in parallel. */
  paymasterSignature?: string;
}

/**
 * V9 details - extends V8 with paymasterSignature for parallelizable signing
 */
export interface AccountAbstractionV9Details {
  userOperation: UserOperationV9;
  /** A User Operation hash. */
  userOperationHash: string;
}

export interface StandardDetails {
  /** The transaction sender. */
  from: string;
  /** The transaction recipient or contract address. */
  to: string;
  /** A contract hashed method call with encoded args. */
  data?: string;
  /** Unique number identifying this transaction. */
  nonce: string;
  /** The gas limit for the transaction. */
  gas: string;
  /** Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to EIP-1559 Transactions. */
  maxFeePerGas: string;
  /** Max priority fee per gas (in wei). Only applies to EIP-1559 Transactions. */
  maxPriorityFeePerGas: string;
  /** Value in wei sent with this transaction. */
  value?: string;
}

export interface TransactionResponseLog {
  blockNumber: number;
  blockHash: string;
  transactionIndex: number;
  removed: boolean;
  address: string;
  data: string;
  topics: string[];
  transactionHash: string;
  logIndex: number;
  orphaned?: boolean;
}

export interface ResponseResponse {
  /** The unix timestamp in seconds when the transactionIntent was created. */
  createdAt: number;
  /** The block height (number) of the block including the transaction of this log. */
  blockNumber?: number;
  /** The transaction hash of the transaction of this log. */
  transactionHash?: string;
  /** The l1 gas used by the transaction of this log. */
  l1GasUsed?: string;
  /** The gas used by the transaction of this log. */
  gasUsed?: string;
  /** The gas fee by the transaction of this log. */
  gasFee?: string;
  /** The l1 gas fee by the transaction of this log. */
  l1GasFee?: string;
  /** The status of the transaction of this log. */
  status?: number;
  /** The logs of the transaction of this log. */
  logs?: TransactionResponseLog[];
  /** The address of the contract of this log. */
  to?: string;
  /** The error of the transaction of this log. */
  error?: unknown;
}

export interface Interaction {
  /** The address of the recipient of native tokens. Use *only* to transfer native tokens. If you provide one of a `pla_...`,  or `acc_...` it will be converted to the corresponding address. */
  to?: string;
  /** The value intended to be sent with the transaction. Should be a stringified number in WEI (i.e. factor 10^18).
* */
  value?: string;
  /** The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`. */
  contract?: string;
  /** The function name of the contract. Accepts a a function signature as well (e.g. mint(address)). */
  functionName?: string;
  /** The function arguments of the contract, in string format. If you provide one of a `pla_...`, `con_...` or `acc_...` it will be converted to the corresponding address. */
  functionArgs?: unknown[];
  /** Data to append to the end of the calldata. Useful for [adding a "domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f) */
  dataSuffix?: string;
  /** The encoded calldata of the contract. */
  data?: string;
}

export type NextActionType = typeof NextActionType[keyof typeof NextActionType];


export const NextActionType = {
  sign_with_wallet: 'sign_with_wallet',
} as const;

export interface NextActionPayload {
  /**
   * The userOperation.
   * @deprecated
   */
  userOp?: unknown;
  /**
   * The hashed userOperation.
   * @deprecated
   */
  userOpHash?: string;
  /**
   * The userOperation.
   * @deprecated
   */
  userOperation?: unknown;
  /**
   * The hashed userOperation.
   * @deprecated
   */
  userOperationHash?: string;
  /** chain-agnostic hash to sign. */
  signableHash?: string;
}

export interface NextActionResponse {
  type: NextActionType;
  payload: NextActionPayload;
}

export type EntityTypeTRANSACTIONINTENT = typeof EntityTypeTRANSACTIONINTENT[keyof typeof EntityTypeTRANSACTIONINTENT];


export const EntityTypeTRANSACTIONINTENT = {
  transactionIntent: 'transactionIntent',
} as const;

export interface TransactionIntentResponse {
  id: string;
  object: EntityTypeTRANSACTIONINTENT;
  createdAt: number;
  /** The unix timestamp in seconds when the transactionIntent was created. */
  updatedAt: number;
  /** The chain ID. */
  chainId: number;
  /** The transaction abstraction type */
  abstractionType: TransactionAbstractionType;
  /** Transition of statuses the transaction has gone through. */
  transitions?: Transition[];
  /** Specific transaction details based on its type */
  details?: ZKSyncDetails | AccountAbstractionV6Details | AccountAbstractionV8Details | AccountAbstractionV9Details | StandardDetails;
  /** @deprecated */
  userOperationHash?: string;
  /** @deprecated */
  userOperation?: unknown;
  response?: ResponseResponse;
  interactions?: Interaction[];
  nextAction?: NextActionResponse;
  /** The policy ID (starts with pol_). */
  policy?: Policy | EntityIdResponse;
  /** The player ID (starts with pla_). */
  player?: Player | EntityIdResponse;
  /** The account ID (starts with acc_). */
  account: Account | EntityIdResponse | DeveloperAccount;
}

export interface TransactionIntentListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: TransactionIntentResponse[];
  start: number;
  end: number;
  total: number;
}

export type ErrorTypeINVALIDREQUESTERROR = typeof ErrorTypeINVALIDREQUESTERROR[keyof typeof ErrorTypeINVALIDREQUESTERROR];


export const ErrorTypeINVALIDREQUESTERROR = {
  invalid_request_error: 'invalid_request_error',
} as const;

export interface FieldErrors {[key: string]: {
  value?: unknown;
  message: string;
}}

export interface InvalidRequestError {
  type: ErrorTypeINVALIDREQUESTERROR;
  message: string;
  details?: FieldErrors;
}

export interface InvalidRequestErrorResponse {
  error: InvalidRequestError;
}

export type TransactionIntentResponseExpandable = typeof TransactionIntentResponseExpandable[keyof typeof TransactionIntentResponseExpandable];


export const TransactionIntentResponseExpandable = {
  policy: 'policy',
  player: 'player',
  account: 'account',
} as const;

export type PrismaSortOrder = typeof PrismaSortOrder[keyof typeof PrismaSortOrder];


export const PrismaSortOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export interface TransactionIntentListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: TransactionIntentResponseExpandable[];
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Filter by account ID or developer account (starts with acc_ or dac_ respectively). */
  account?: string[];
  /** Filter by player ID (starts with pla_). */
  player?: string[];
  /** Filter by successful (1) or failed (0) transaction intents. */
  status?: number;
  /** Filter by policy ID (starts with pol_). */
  policy?: string[];
}

export interface CreateTransactionIntentRequest {
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** ID of the Player this TransactionIntent belongs to, if one exists (starts with `pla_`).

If you omit this parameter a new Player will be created. */
  player?: string;
  /** ID of the Account this TransactionIntent is executed with, if one exists (starts with `acc_` or `dac_`).

When providing a Player and ChainID, you can omit this parameter. */
  account?: string;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas. */
  policy?: string;
  /** Use this parameter to create a new Account for Player with the provided owner address.

If you omit this parameter and no Account exists for the Player, a custodial Account will be created. */
  externalOwnerAddress?: string;
  /** Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain. */
  optimistic?: boolean;
  /** Signed authorization for delegated accounts. This signature is used to authorize the user operation for AccountAbstractionV8.
The signature should be in the format "0x..." and will be parsed to extract r, s, and yParity values. */
  signedAuthorization?: string;
  interactions: Interaction[];
}

/**
 * return value from estimateTransactionIntentCost
 */
export interface EstimateTransactionIntentGasResult {
  /** estimated TX gas cost */
  estimatedTXGas: string;
  /** estimated TX gas cost in the chain native token (WEI) */
  estimatedTXGasFee: string;
  /** estimated TX gas cost in USD */
  estimatedTXGasFeeUSD: string;
  /** when using a policy, the estimated TX gas cost in the ERC-20 token defined in the strategy (WEI) */
  estimatedTXGasFeeToken?: string;
  /** gas price used for the estimation */
  gasPrice: string;
}

export interface SignatureRequest {
  /** signed userOperationHash by the owner or valid session key */
  signature: string;
  /** Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain. */
  optimistic?: boolean;
}

export type APITopic = typeof APITopic[keyof typeof APITopic];


export const APITopic = {
  transaction_intentbroadcast: 'transaction_intent.broadcast',
  transaction_intentsuccessful: 'transaction_intent.successful',
  transaction_intentcancelled: 'transaction_intent.cancelled',
  transaction_intentfailed: 'transaction_intent.failed',
  balanceproject: 'balance.project',
  balancecontract: 'balance.contract',
  balancedev_account: 'balance.dev_account',
  test: 'test',
  usercreated: 'user.created',
  userupdated: 'user.updated',
  userdeleted: 'user.deleted',
  accountcreated: 'account.created',
} as const;

export type APITriggerType = typeof APITriggerType[keyof typeof APITriggerType];


export const APITriggerType = {
  webhook: 'webhook',
  email: 'email',
} as const;

export type EntityTypeTRIGGER = typeof EntityTypeTRIGGER[keyof typeof EntityTypeTRIGGER];


export const EntityTypeTRIGGER = {
  trigger: 'trigger',
} as const;

export interface TriggerResponse {
  id: string;
  object: EntityTypeTRIGGER;
  createdAt: number;
  target: string;
  type: APITriggerType;
  subscription: string;
  updatedAt?: number;
}

export type EntityTypeSUBSCRIPTION = typeof EntityTypeSUBSCRIPTION[keyof typeof EntityTypeSUBSCRIPTION];


export const EntityTypeSUBSCRIPTION = {
  subscription: 'subscription',
} as const;

export interface SubscriptionResponse {
  id: string;
  object: EntityTypeSUBSCRIPTION;
  createdAt: number;
  topic: APITopic;
  triggers: TriggerResponse[];
  updatedAt?: number;
}

export interface SubscriptionListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: SubscriptionResponse[];
  start: number;
  end: number;
  total: number;
}

export type Status = typeof Status[keyof typeof Status];


export const Status = {
  success: 'success',
  failed: 'failed',
} as const;

export type EntityTypeLOG = typeof EntityTypeLOG[keyof typeof EntityTypeLOG];


export const EntityTypeLOG = {
  log: 'log',
} as const;

export interface LogResponse {
  id: string;
  object: EntityTypeLOG;
  createdAt: number;
  topic: APITopic;
  status: Status;
  subscription: string;
  trigger: string;
  requestID: string;
}

export interface BaseEntityListResponseLogResponse {
  object: ResponseTypeLIST;
  url: string;
  data: LogResponse[];
  start: number;
  end: number;
  total: number;
}

export type SubscriptionLogsResponse = BaseEntityListResponseLogResponse;

export interface ListSubscriptionLogsRequest {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the topic of the subscription logs */
  topic?: APITopic;
  /** Specifies the status of the subscription logs */
  status?: Status;
  /** Specifies the object ID of the object related to triggered notification */
  object?: string;
  /** Specifies the subscription ID */
  subscription?: string;
  /** Specifies the trigger ID */
  trigger?: string;
  /** Specifies the request ID */
  requestID?: string;
}

export type GetSubscriptionResponse = SubscriptionResponse;

export type CreateSubscriptionResponse = SubscriptionResponse;

export interface CreateTriggerRequest {
  /** Specifies the target of the trigger */
  target: string;
  /** Specifies the type of the trigger */
  type: APITriggerType;
  /** Specifies the subscription ID */
  subscription?: string;
}

export interface CreateSubscriptionRequest {
  /** Specifies the topic of the subscription */
  topic: APITopic;
  /** Specifies the triggers of the subscription */
  triggers: CreateTriggerRequest[];
}

export interface SubscriptionDeleteResponse {
  id: string;
  object: EntityTypeSUBSCRIPTION;
  deleted: boolean;
}

export interface BaseEntityListResponseTriggerResponse {
  object: ResponseTypeLIST;
  url: string;
  data: TriggerResponse[];
  start: number;
  end: number;
  total: number;
}

export type TriggerListResponse = BaseEntityListResponseTriggerResponse;

export type GetTriggerResponse = TriggerResponse;

export type CreateTriggerResponse = TriggerResponse;

export interface TriggerDeleteResponse {
  id: string;
  object: EntityTypeTRIGGER;
  deleted: boolean;
}

export interface TransactionIntent {
  id: string;
  object: EntityTypeTRANSACTIONINTENT;
  createdAt: number;
  /** The unix timestamp in seconds when the transactionIntent was created. */
  updatedAt: number;
  /** The chain ID. */
  chainId: number;
  /** The transaction abstraction type */
  abstractionType: TransactionAbstractionType;
  /** Transition of statuses the transaction has gone through. */
  transitions?: Transition[];
  /** Specific transaction details based on its type */
  details?: ZKSyncDetails | AccountAbstractionV6Details | AccountAbstractionV8Details | AccountAbstractionV9Details | StandardDetails;
  /** @deprecated */
  userOperationHash?: string;
  /** @deprecated */
  userOperation?: unknown;
  response?: ResponseResponse;
  interactions?: Interaction[];
  nextAction?: NextActionResponse;
  /** The policy ID (starts with pol_). */
  policy?: EntityIdResponse;
  /** The player ID (starts with pla_). */
  player?: EntityIdResponse;
  /** The account ID. */
  account: EntityIdResponse;
}

export interface DeveloperAccountResponse {
  id: string;
  object: EntityTypeDEVELOPERACCOUNT;
  createdAt: number;
  address: string;
  custodial: boolean;
  name?: string;
  transactionIntents?: (TransactionIntent | EntityIdResponse)[];
}

export interface DeveloperAccountListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: DeveloperAccountResponse[];
  start: number;
  end: number;
  total: number;
}

export type DeveloperAccountResponseExpandable = typeof DeveloperAccountResponseExpandable[keyof typeof DeveloperAccountResponseExpandable];


export const DeveloperAccountResponseExpandable = {
  transactionIntents: 'transactionIntents',
} as const;

export interface DeveloperAccountListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: DeveloperAccountResponseExpandable[];
  /** Specifies whether to include deleted dev accounts. */
  deleted?: boolean;
}

export interface CreateDeveloperAccountCreateRequest {
  /** The address of the wallet that has deposited funds in the paymaster. */
  address?: string;
  /** Signature to verify the account ownership. */
  signature?: string;
  /** The name of the account. */
  name?: string;
}

export type EntityTypeSIGNATURE = typeof EntityTypeSIGNATURE[keyof typeof EntityTypeSIGNATURE];


export const EntityTypeSIGNATURE = {
  signature: 'signature',
} as const;

export interface SignPayloadResponse {
  object: EntityTypeSIGNATURE;
  account: string;
  address: string;
  hash: string;
  signature: string;
}

export interface TypedDomainData {
  /** The chain ID. */
  chainId: number;
  /** The user readable name of signing domain, i.e. the name of the DApp or the protocol.. */
  name?: string;
  /** The current major version of the signing domain. Signatures from different versions are not compatible. */
  version?: string;
  /** The address of the contract that will verify the signature. The user-agent may do contract specific phishing prevention. */
  verifyingContract?: string;
  /** An disambiguating salt for the protocol. This can be used as a domain separator of last resort. */
  salt?: string;
}

export interface TypedDataField {
  name: string;
  type: string;
}

export type SignPayloadRequestTypes = {[key: string]: TypedDataField[]};

export type SignPayloadRequestValue = {[key: string]: unknown};

export interface SignPayloadRequest {
  /** Domain. Specific to the dApp. */
  domain: TypedDomainData;
  types: SignPayloadRequestTypes;
  primaryType: string;
  value: SignPayloadRequestValue;
  /** Hash to verify and that will be signed */
  hash?: string;
}

export interface UpdateDeveloperAccountCreateRequest {
  /** The name of the account. */
  name?: string;
}

export interface DeveloperAccountGetMessageResponse {
  message: string;
  address: string;
}

export interface DeveloperAccountDeleteResponse {
  id: string;
  object: EntityTypeDEVELOPERACCOUNT;
  deleted: boolean;
}

export type EntityTypeSESSION = typeof EntityTypeSESSION[keyof typeof EntityTypeSESSION];


export const EntityTypeSESSION = {
  session: 'session',
} as const;

export interface SessionResponse {
  id: string;
  object: EntityTypeSESSION;
  createdAt: number;
  updatedAt: number;
  isActive: boolean;
  address: string;
  validAfter: string;
  validUntil: string;
  /** The account ID. */
  account: EntityIdResponse;
  whitelist: string[];
  limit: number;
  nextAction?: NextActionResponse;
  transactionIntents?: (TransactionIntent | EntityIdResponse)[];
}

export interface SessionListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: SessionResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 * Contains list of the expandable fields for the session response
 */
export type SessionResponseExpandable = typeof SessionResponseExpandable[keyof typeof SessionResponseExpandable];


export const SessionResponseExpandable = {
  transactionIntents: 'transactionIntents',
} as const;

export interface SessionListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** The player ID (starts with pla_) */
  player: string;
  /** Specifies the fields to expand in the response. */
  expand?: SessionResponseExpandable[];
}

export interface CreateSessionRequest {
  /** The address of the session key. */
  address: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** If no account exists for a given player, create one with this address. */
  externalOwnerAddress?: string;
  /**
   * Maximum number of times the session key can be used.
   * @minimum 1
   */
  limit?: number;
  /** Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain. */
  optimistic?: boolean;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas. */
  policy?: string;
  /** The unix timestamp in seconds when the session key becomes valid. */
  validAfter: number;
  /** The unix timestamp in seconds when the session key expires. */
  validUntil: number;
  /** The list of whitelisted addresses (contracts the session key can interact with). */
  whitelist?: string[];
  /** The player ID (starts with pla_). */
  player?: string;
  /** ID of the Account this TransactionIntent is executed with, if one exists (starts with `acc_` or `dac_`).

When providing a Player and ChainID, you can omit this parameter. */
  account?: string;
}

export interface RevokeSessionRequest {
  /** The address of the session key to revoke. */
  address: string;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas. */
  policy?: string;
  /** Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not. */
  optimistic?: boolean;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** The player ID (starts with pla_). */
  player?: string;
  /** ID of the Account this TransactionIntent is executed with, if one exists (starts with `acc_` or `dac_`).

When providing a Player and ChainID, you can omit this parameter. */
  account?: string;
}

export type PolicyRuleTypeCONTRACT = typeof PolicyRuleTypeCONTRACT[keyof typeof PolicyRuleTypeCONTRACT];


export const PolicyRuleTypeCONTRACT = {
  contract_functions: 'contract_functions',
} as const;

export type PolicyRuleType = typeof PolicyRuleType[keyof typeof PolicyRuleType];


export const PolicyRuleType = {
  contract_functions: 'contract_functions',
  account_functions: 'account_functions',
  rate_limit: 'rate_limit',
} as const;

export type EntityTypePOLICYRULE = typeof EntityTypePOLICYRULE[keyof typeof EntityTypePOLICYRULE];


export const EntityTypePOLICYRULE = {
  policyRule: 'policyRule',
} as const;

export interface AbiType {
  name?: string;
  type?: string;
  indexed?: boolean;
  internalType?: unknown;
  components?: AbiType[];
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickJsonFragmentTypeExcludeKeyofJsonFragmentTypeComponents {
  name?: string;
  type?: string;
  indexed?: boolean;
  internalType?: unknown;
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickJsonFragmentExcludeKeyofJsonFragmentInputsOrOutputs {
  name?: string;
  type?: string;
  anonymous?: boolean;
  payable?: boolean;
  constant?: boolean;
  stateMutability?: string;
  gas?: string;
}

export interface Abi {
  name?: string;
  type?: string;
  anonymous?: boolean;
  payable?: boolean;
  constant?: boolean;
  stateMutability?: string;
  gas?: string;
  inputs?: AbiType[];
  outputs?: AbiType[];
}

export type EntityTypeCONTRACT = typeof EntityTypeCONTRACT[keyof typeof EntityTypeCONTRACT];


export const EntityTypeCONTRACT = {
  contract: 'contract',
} as const;

export interface ContractResponse {
  id: string;
  object: EntityTypeCONTRACT;
  createdAt: number;
  /** @nullable */
  name: string | null;
  /** The chain ID. */
  chainId: number;
  address: string;
  deleted: boolean;
  abi: Abi[];
  publicVerification: boolean;
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickContractResponseId {
  id: string;
}

export interface ContractPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeCONTRACT;
  contract?: ContractResponse | PickContractResponseId;
  functionName?: string;
  wildcard: boolean;
}

export type PolicyRuleTypeACCOUNT = typeof PolicyRuleTypeACCOUNT[keyof typeof PolicyRuleTypeACCOUNT];


export const PolicyRuleTypeACCOUNT = {
  account_functions: 'account_functions',
} as const;

export interface AccountPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeACCOUNT;
}

export type PolicyRateLimitGASPERTRANSACTION = typeof PolicyRateLimitGASPERTRANSACTION[keyof typeof PolicyRateLimitGASPERTRANSACTION];


export const PolicyRateLimitGASPERTRANSACTION = {
  gas_per_transaction: 'gas_per_transaction',
} as const;

export type PolicyRuleTypeRATELIMIT = typeof PolicyRuleTypeRATELIMIT[keyof typeof PolicyRuleTypeRATELIMIT];


export const PolicyRuleTypeRATELIMIT = {
  rate_limit: 'rate_limit',
} as const;

export type PolicyRateLimit = typeof PolicyRateLimit[keyof typeof PolicyRateLimit];


export const PolicyRateLimit = {
  gas_per_transaction: 'gas_per_transaction',
  gas_per_interval: 'gas_per_interval',
  count_per_interval: 'count_per_interval',
} as const;

export interface GasPerTransactionLimitPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeRATELIMIT;
  functionName: PolicyRateLimitGASPERTRANSACTION;
  gasLimit: string;
}

export type PolicyRateLimitGASPERINTERVAL = typeof PolicyRateLimitGASPERINTERVAL[keyof typeof PolicyRateLimitGASPERINTERVAL];


export const PolicyRateLimitGASPERINTERVAL = {
  gas_per_interval: 'gas_per_interval',
} as const;

export type TimeIntervalType = typeof TimeIntervalType[keyof typeof TimeIntervalType];


export const TimeIntervalType = {
  minute: 'minute',
  hour: 'hour',
  day: 'day',
  week: 'week',
  month: 'month',
} as const;

export interface GasPerIntervalLimitPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeRATELIMIT;
  functionName: PolicyRateLimitGASPERINTERVAL;
  gasLimit: string;
  timeIntervalType: TimeIntervalType;
  timeIntervalValue: number;
}

export type PolicyRateLimitCOUNTPERINTERVAL = typeof PolicyRateLimitCOUNTPERINTERVAL[keyof typeof PolicyRateLimitCOUNTPERINTERVAL];


export const PolicyRateLimitCOUNTPERINTERVAL = {
  count_per_interval: 'count_per_interval',
} as const;

export interface CountPerIntervalLimitPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeRATELIMIT;
  functionName: PolicyRateLimitCOUNTPERINTERVAL;
  countLimit: number;
  timeIntervalType: TimeIntervalType;
  timeIntervalValue: number;
}

export type PolicyRuleResponse = ContractPolicyRuleResponse | AccountPolicyRuleResponse | GasPerTransactionLimitPolicyRuleResponse | GasPerIntervalLimitPolicyRuleResponse | CountPerIntervalLimitPolicyRuleResponse;

export interface PolicyRuleListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: PolicyRuleResponse[];
  start: number;
  end: number;
  total: number;
}

export type PolicyRuleListQueriesExpandItem = typeof PolicyRuleListQueriesExpandItem[keyof typeof PolicyRuleListQueriesExpandItem];


export const PolicyRuleListQueriesExpandItem = {
  contract: 'contract',
} as const;

export interface PolicyRuleListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: PolicyRuleListQueriesExpandItem[];
  /** Specifies the unique policy ID (starts with pol_). */
  policy: string;
}

export interface CreatePolicyRuleRequest {
  /** The type of rule to add. */
  type: PolicyRuleType;
  /** Name of the function in the contract to allow. If you want to allow all functions, use the wildcard 'All functions'. */
  functionName?: string;
  /** The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`. */
  contract?: string;
  /** When using `contract_functions` type, set this to `true` to allow all contracts. */
  wildcard?: boolean;
  /** Gas limit in WEI (i.e. factor 10^18). */
  gasLimit?: string;
  /** Number of times the function will be sponsored. */
  countLimit?: number;
  /** Time interval between sponsorships. */
  timeIntervalType?: TimeIntervalType;
  /** Time interval value. */
  timeIntervalValue?: number;
  /** The unique Policy ID to add the rule to (starts with pol_). */
  policy: string;
}

export interface UpdatePolicyRuleRequest {
  /** The type of rule to add. */
  type: PolicyRuleType;
  /** Name of the function in the contract to allow. If you want to allow all functions, use the wildcard 'All functions'. */
  functionName?: string;
  /** The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`. */
  contract?: string;
  /** When using `contract_functions` type, set this to `true` to allow all contracts. */
  wildcard?: boolean;
  /** Gas limit in WEI (i.e. factor 10^18). */
  gasLimit?: string;
  /** Number of times the function will be sponsored. */
  countLimit?: number;
  /** Time interval between sponsorships. */
  timeIntervalType?: TimeIntervalType;
  /** Time interval value. */
  timeIntervalValue?: number;
}

export interface PolicyRuleDeleteResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  deleted: boolean;
}

export interface PolicyResponse {
  id: string;
  object: EntityTypePOLICY;
  createdAt: number;
  /** @nullable */
  name: string | null;
  deleted: boolean;
  enabled: boolean;
  /** The chain ID. */
  chainId: number;
  paymaster?: EntityIdResponse;
  forwarderContract?: EntityIdResponse;
  strategy: PolicyStrategy;
  transactionIntents: (TransactionIntent | EntityIdResponse)[];
  policyRules: (PolicyRuleResponse | EntityIdResponse)[];
}

export interface PolicyListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: PolicyResponse[];
  start: number;
  end: number;
  total: number;
}

export type PolicyResponseExpandable = typeof PolicyResponseExpandable[keyof typeof PolicyResponseExpandable];


export const PolicyResponseExpandable = {
  transactionIntents: 'transactionIntents',
  policyRules: 'policyRules',
} as const;

export interface PolicyListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: PolicyResponseExpandable[];
  /** Specifies the name of the policy. */
  name?: string;
  /** Specifies whether to include deleted policies. */
  deleted?: boolean;
  /** The chain ID of the policy. */
  chainId?: number;
  /** Specifies whether to include enabled policies. */
  enabled?: boolean;
}

export interface PolicyStrategyRequest {
  /** The sponsor schema of the policy. */
  sponsorSchema: SponsorSchema;
  /** If the user pays in custom tokens, the contract ID (starts with con_) of the token contract. */
  tokenContract?: string;
  /** If the user pays in ERC20 tokens, this reflects either the exchange rate or the amount in WEI. */
  tokenContractAmount?: string;
  /** If the you want to use your own native tokens to pay for gas, specify the developer account ID (starts with dac_) */
  depositor?: string;
}

export interface CreatePolicyRequest {
  /** Specifies the name of the policy. */
  name: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** The sponsor schema of the policy. */
  strategy: PolicyStrategyRequest;
  /** The ID of the paymaster. */
  paymaster?: string;
  /** The ID of the forwarder contract. */
  forwarderContract?: string;
}

export interface UpdatePolicyRequest {
  /** Specifies the name of the policy. */
  name?: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** The sponsor schema of the policy. */
  strategy?: PolicyStrategyRequest;
  /** The ID of the paymaster. */
  paymaster?: string;
  /** The ID of the forwarder contract. */
  forwarderContract?: string;
  /** Specifies whether to delete the policy. */
  deleted?: boolean;
}

export interface PolicyDeleteResponse {
  id: string;
  object: EntityTypePOLICY;
  deleted: boolean;
}

export interface MonthRange {
  start: number;
  end: number;
}

export interface GasReportTransactionIntents {
  id: string;
  gasFee: string;
  gasPrice: string;
  gasUsed: string;
  gasFeeInUSD: string;
}

export interface GasReport {
  period: MonthRange;
  averageTransactionFee: string;
  totalTransactionFeeInCustomTokens: string;
  totalTransactionFee: string;
  totalTransactionFeeInUSD: string;
  /** @deprecated */
  transactionIntents: GasReportTransactionIntents[];
}

export interface GasReportListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: GasReport[];
  start: number;
  end: number;
  total: number;
}

export interface PolicyReportQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
}

export interface GasReportTransactionIntentsListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: GasReportTransactionIntents[];
  start: number;
  end: number;
  total: number;
}

export interface PolicyReportTransactionIntentsQueries {
  /** The start date of the period in unix timestamp. */
  to: number;
  /** The end date of the period in unix timestamp. */
  from: number;
}

export interface PolicyBalanceWithdrawResponse {
  policy: string;
  balance: string;
  contract: string;
}

export interface WithdrawalPolicyRequest {
  /** ID of the Dev Account this TransactionIntent will send the specified amount of tokens to (starts with `dac_`). */
  account: string;
  /** Amount in WEI to withdraw (i.e. factor 10^18).. */
  amount: string;
}

export interface PlayerResponse {
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  name: string;
  description?: string;
  metadata?: PlayerMetadata;
  transactionIntents?: (TransactionIntent | EntityIdResponse)[];
  accounts?: (Account | EntityIdResponse)[];
}

export interface PlayerListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: PlayerResponse[];
  start: number;
  end: number;
  total: number;
}

export type PlayerResponseExpandable = typeof PlayerResponseExpandable[keyof typeof PlayerResponseExpandable];


export const PlayerResponseExpandable = {
  transactionIntents: 'transactionIntents',
  accounts: 'accounts',
} as const;

export interface PlayerListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: PlayerResponseExpandable[];
  /** Filter by player name. */
  name?: string;
}

export interface PlayerCreateRequest {
  /**
   * Specifies the player name.
   * @minLength 1
   * @maxLength 256
   */
  name?: string;
  /** Specifies the player description. */
  description?: string;
  /** Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata. */
  metadata?: PlayerMetadata;
}

export interface PlayerUpdateRequest {
  /**
   * Specifies the player name.
   * @minLength 1
   * @maxLength 256
   */
  name?: string;
  /** Specifies the player description. */
  description?: string;
  /** Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata. */
  metadata?: PlayerMetadata;
}

export interface PlayerDeleteResponse {
  id: string;
  object: EntityTypePLAYER;
  deleted: boolean;
}

export interface PlayerTransferOwnershipRequest {
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided. */
  policy: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** The address of the new owner */
  newOwnerAddress: string;
  /** ID of the Player that has the Account you want to transfer ownership from (starts with `pla_`). */
  player?: string;
}

export interface PlayerCancelTransferOwnershipRequest {
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided. */
  policy: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
}

export type EntityTypePAYMASTER = typeof EntityTypePAYMASTER[keyof typeof EntityTypePAYMASTER];


export const EntityTypePAYMASTER = {
  paymaster: 'paymaster',
} as const;

export type PaymasterResponseContext = { [key: string]: unknown };

export interface PaymasterResponse {
  id: string;
  object: EntityTypePAYMASTER;
  createdAt: number;
  address: string;
  url?: string;
  context?: PaymasterResponseContext;
}

export type CreatePaymasterResponse = PaymasterResponse;

/**
 * Specifies the context, that is, the arbitrary repositories that the specific paymaster may require
 */
export type CreatePaymasterRequestContext = { [key: string]: unknown };

export interface CreatePaymasterRequest {
  /** Specifies the address of the paymaster */
  address: string;
  /** Specifies the paymaster URL */
  url?: string;
  /** Specifies the context, that is, the arbitrary repositories that the specific paymaster may require */
  context?: CreatePaymasterRequestContext;
  /** Specifies the name of the paymaster */
  name?: string;
}

export interface PagingQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
}

export interface PaymasterDeleteResponse {
  id: string;
  object: EntityTypePAYMASTER;
  deleted: boolean;
}

export type OnrampProvider = typeof OnrampProvider[keyof typeof OnrampProvider];


export const OnrampProvider = {
  coinbase: 'coinbase',
  stripe: 'stripe',
} as const;

/**
 * Common fee structure for onramp operations
 */
export interface OnrampFee {
  type: string;
  amount: string;
  currency: string;
}

export type OnrampSessionResponseQuote = {
  exchangeRate?: string;
  fees?: OnrampFee[];
  destinationNetwork?: string;
  destinationCurrency?: string;
  destinationAmount?: string;
  sourceCurrency?: string;
  sourceAmount?: string;
};

/**
 * Common unified response format for creating an onramp session.
This format is provider-agnostic.
 */
export interface OnrampSessionResponse {
  provider: OnrampProvider;
  sessionId?: string;
  clientSecret?: string;
  status?: string;
  onrampUrl: string;
  redirectUrl?: string;
  quote?: OnrampSessionResponseQuote;
}

/**
 * Common unified request format for creating an onramp session.
This format is provider-agnostic and will be adapted by each provider service.
 */
export interface OnrampSessionRequest {
  provider: OnrampProvider;
  destinationCurrency: string;
  destinationNetwork: string;
  destinationAddress: string;
  sourceAmount?: string;
  sourceCurrency?: string;
  redirectUrl?: string;
  country?: string;
  subdivision?: string;
  paymentMethod?: string;
  clientIp?: string;
}

/**
 * Common unified response format for getting an onramp quote.
This format is provider-agnostic.
 */
export interface OnrampQuoteResponse {
  provider: OnrampProvider;
  sourceAmount: string;
  sourceCurrency: string;
  destinationAmount: string;
  destinationCurrency: string;
  destinationNetwork: string;
  fees: OnrampFee[];
  exchangeRate: string;
}

/**
 * Response type for quote requests that can return either a single quote or multiple quotes.
- Returns OnrampQuoteResponse when provider is specified
- Returns OnrampQuoteResponse[] when provider is not specified
 */
export type OnrampQuotesResponse = OnrampQuoteResponse | OnrampQuoteResponse[];

/**
 * Common unified request format for getting an onramp quote.
This format is provider-agnostic and will be adapted by each provider service.
If provider is specified, returns a single quote for that provider.
If provider is not specified, returns quotes from all available providers.
 */
export interface OnrampQuoteRequest {
  provider?: OnrampProvider;
  sourceCurrency: string;
  destinationCurrency: string;
  destinationNetwork: string;
  sourceAmount: string;
  paymentMethod?: string;
  country?: string;
  subdivision?: string;
}

export interface Log {
  id: string;
  timestamp: string;
  event: string;
  request_body: unknown;
  status: number;
  response_time: number;
  response_data: unknown;
}

export interface ProjectLogs {
  object: ResponseTypeLIST;
  url: string;
  data: Log[];
  start: number;
  end: number;
  total: number;
}

export type EntityTypeFORWARDERCONTRACT = typeof EntityTypeFORWARDERCONTRACT[keyof typeof EntityTypeFORWARDERCONTRACT];


export const EntityTypeFORWARDERCONTRACT = {
  forwarderContract: 'forwarderContract',
} as const;

export interface ForwarderContractResponse {
  id: string;
  object: EntityTypeFORWARDERCONTRACT;
  createdAt: number;
  address: string;
  chainId: number;
  name?: string;
}

export type CreateForwarderContractResponse = ForwarderContractResponse;

export interface CreateForwarderContractRequest {
  /** Specifies the address of the paymaster */
  address: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** Specifies the name of the paymaster */
  name?: string;
}

export interface ForwarderContractDeleteResponse {
  id: string;
  object: EntityTypeFORWARDERCONTRACT;
  deleted: boolean;
}

export type APITopicBALANCECONTRACT = typeof APITopicBALANCECONTRACT[keyof typeof APITopicBALANCECONTRACT];


export const APITopicBALANCECONTRACT = {
  balancecontract: 'balance.contract',
} as const;

export type EntityTypeEVENT = typeof EntityTypeEVENT[keyof typeof EntityTypeEVENT];


export const EntityTypeEVENT = {
  event: 'event',
} as const;

export interface ContractEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicBALANCECONTRACT;
  threshold: string;
  contract: EntityIdResponse;
  functionName: string;
  functionArgs: string[];
}

export type APITopicBALANCEDEVACCOUNT = typeof APITopicBALANCEDEVACCOUNT[keyof typeof APITopicBALANCEDEVACCOUNT];


export const APITopicBALANCEDEVACCOUNT = {
  balancedev_account: 'balance.dev_account',
} as const;

export interface AccountEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicBALANCEDEVACCOUNT;
  threshold: string;
  developerAccount: EntityIdResponse;
  chainId: number;
}

export type APITopicBALANCEPROJECT = typeof APITopicBALANCEPROJECT[keyof typeof APITopicBALANCEPROJECT];


export const APITopicBALANCEPROJECT = {
  balanceproject: 'balance.project',
} as const;

export interface BalanceEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicBALANCEPROJECT;
  threshold: string;
}

export type APITopicTRANSACTIONSUCCESSFUL = typeof APITopicTRANSACTIONSUCCESSFUL[keyof typeof APITopicTRANSACTIONSUCCESSFUL];


export const APITopicTRANSACTIONSUCCESSFUL = {
  transaction_intentsuccessful: 'transaction_intent.successful',
} as const;

export interface TransactionConfirmedEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicTRANSACTIONSUCCESSFUL;
  numberOfBlocks: number;
}

export type EventResponse = ContractEventResponse | AccountEventResponse | BalanceEventResponse | TransactionConfirmedEventResponse;

export interface EventListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: EventResponse[];
  start: number;
  end: number;
  total: number;
}

export interface EventListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the name of the event */
  name?: string;
  /** Specifies if display deleted events */
  deleted?: boolean;
}

export type GetEventResponse = EventResponse;

export type CreateEventResponse = EventResponse;

export interface CreateEventRequest {
  /** Specifies the name of the event */
  name: string;
  /** Specifies the type of the event (transaction_intent.successful, balance.project, balance.contract, balance.dev_account) */
  topic: APITopic;
  /** Specifies the contract id (if the event is a contract event) */
  contract?: string;
  /** Specifies the function arguments (if the event is a contract event) */
  functionArgs?: string[];
  /** Specifies the function name (if the event is a contract event) */
  functionName?: string;
  /** Specifies the developer account id (if the event is a developer account event) */
  developerAccount?: string;
  /** Specifies the chain id (if the event is a developer account event) */
  chainId?: number;
  /** Threshold for the event (if the event is a contract, dev account or project event) */
  threshold?: string;
  /** Specifies the number of confirmations required for the event to trigger */
  numberOfBlocks?: number;
}

export interface EventDeleteResponse {
  id: string;
  object: EntityTypeEVENT;
  deleted: boolean;
}

export interface EmbeddedResponse {
  share: string;
  accountType: string;
  address: string;
  chainId: number;
  deviceId?: string;
}

export type EmbeddedNextActionResponseNextAction = typeof EmbeddedNextActionResponseNextAction[keyof typeof EmbeddedNextActionResponseNextAction];


export const EmbeddedNextActionResponseNextAction = {
  RECOVER: 'RECOVER',
  REGISTER: 'REGISTER',
} as const;

export interface EmbeddedNextActionResponse {
  nextAction: EmbeddedNextActionResponseNextAction;
  player: string;
  embedded?: EmbeddedResponse;
}

export interface InitEmbeddedRequest {
  chainId: number;
}

export interface EmbeddedV2Response {
  share?: string;
  accountType: string;
  implementationType?: string;
  implementationAddress?: string;
  factoryAddress?: string;
  salt?: string;
  address: string;
  ownerAddress: string;
  chainType: string;
  chainId?: number;
  device?: string;
  account: string;
  signer: string;
}

export interface RegisterEmbeddedRequest {
  chainId: number;
  address: string;
  share: string;
  signerUuid?: string;
}

export interface SwitchChainRequest {
  chainId: number;
  deviceId: string;
}

export interface ExportedEmbeddedRequest {
  address: string;
}

export type EntityTypeDEVICE = typeof EntityTypeDEVICE[keyof typeof EntityTypeDEVICE];


export const EntityTypeDEVICE = {
  device: 'device',
} as const;

export interface DeviceResponse {
  id: string;
  object: EntityTypeDEVICE;
  createdAt: number;
  account: string;
  share: string;
  isPrimary: boolean;
}

export interface BaseEntityListResponseDeviceResponse {
  object: ResponseTypeLIST;
  url: string;
  data: DeviceResponse[];
  start: number;
  end: number;
  total: number;
}

export type DeviceListResponse = BaseEntityListResponseDeviceResponse;

export interface DeviceListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the unique account ID (starts with acc_) */
  account: string;
}

export type GetDeviceResponse = DeviceResponse;

export type CreateDeviceResponse = DeviceResponse;

export interface CreateDeviceRequest {
  /** Specifies the unique account ID (starts with acc_) */
  account: string;
  /** Specifies the share repositories */
  share: string;
}

export interface ContractListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: ContractResponse[];
  start: number;
  end: number;
  total: number;
}

export interface ContractListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the name of the contract. */
  name?: string;
  /** Specifies whether to include deleted contracts. */
  deleted?: boolean;
  /** The chain ID of the contract. */
  chainId?: number;
  /** Specifies the address of the contract. */
  address?: string;
}

export interface CreateContractRequest {
  /** Specifies the name of the contract (Only for display purposes). */
  name: string;
  /** Specifies the chain ID of the contract. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** Specifies the address of the contract. */
  address: string;
  /** Specifies the ABI of the contract. */
  abi?: Abi[];
  /** Specifies whether to verify the contract publicly. */
  publicVerification?: boolean;
}

export interface UpdateContractRequest {
  /** Specifies the name of the contract (Only for display purposes). */
  name?: string;
  /** Specifies the chain ID of the contract. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Specifies whether to delete the contract. */
  deleted?: boolean;
  /** Specifies the address of the contract. */
  address?: string;
  /** Specifies the ABI of the contract. */
  abi?: Abi[];
  /** Specifies whether to verify the contract publicly. */
  publicVerification?: boolean;
}

export type EntityTypeREADCONTRACT = typeof EntityTypeREADCONTRACT[keyof typeof EntityTypeREADCONTRACT];


export const EntityTypeREADCONTRACT = {
  readContract: 'readContract',
} as const;

export interface ContractReadResponse {
  id: string;
  object: EntityTypeREADCONTRACT;
  createdAt: number;
  functionName: string;
  result: unknown;
}

export interface ContractReadQueries {
  /** The function name of the contract. */
  functionName: string;
  /** The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs. */
  functionArgs?: unknown[];
}

export interface ContractDeleteResponse {
  id: string;
  object: EntityTypeCONTRACT;
  deleted: boolean;
}

export interface AccountResponse {
  id: string;
  object: EntityTypeACCOUNT;
  createdAt: number;
  address: string;
  ownerAddress: string;
  deployed: boolean;
  custodial: boolean;
  embeddedSigner: boolean;
  /** The chain ID. */
  chainId: number;
  accountType: string;
  pendingOwnerAddress?: string;
  transactionIntents?: (TransactionIntent | EntityIdResponse)[];
  player: EntityIdResponse | Player;
}

export interface AccountListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AccountResponse[];
  start: number;
  end: number;
  total: number;
}

export type AccountResponseExpandable = typeof AccountResponseExpandable[keyof typeof AccountResponseExpandable];


export const AccountResponseExpandable = {
  player: 'player',
  transactionIntents: 'transactionIntents',
} as const;

export interface AccountListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Specifies the unique player ID (starts with pla_) */
  player?: string;
  /** Specifies the address of the account */
  address?: string;
  /** Specifies the fields to expand in the response. */
  expand?: AccountResponseExpandable[];
}

export interface CreateAccountRequest {
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** Use this parameter to create a new Account for Player with the provided owner address. */
  externalOwnerAddress?: string;
  /** The type of smart account that will be created (e.g. UpgradeableV6, UpgradeableV5, ZKSyncUpgradeableV2). Defaults to UpgradeableV6. */
  accountType?: string;
  /** For account types that support social recovery, wether to enable Openfort as guardian or not. Defaults to false. */
  defaultGuardian?: boolean;
  /** ID of the player this account belongs to (starts with `pla_`). If none is provided, a new player will be created. */
  player?: string;
}

export type AuthProviderResponseV2 = typeof AuthProviderResponseV2[keyof typeof AuthProviderResponseV2];


export const AuthProviderResponseV2 = {
  credential: 'credential',
  email: 'email',
  wallet: 'wallet',
  google: 'google',
  apple: 'apple',
  twitter: 'twitter',
  discord: 'discord',
  facebook: 'facebook',
  custom: 'custom',
  oidc: 'oidc',
  siwe: 'siwe',
} as const;

export interface LinkedAccountResponseV2 {
  provider: AuthProviderResponseV2;
  createdAt: number;
  updatedAt: number;
  accountId?: string;
  chainType?: string;
  connectorType?: string;
  walletClientType?: string;
}

export interface AuthUserResponse {
  id: string;
  createdAt: number;
  name: string;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phoneNumber: string | null;
  phoneNumberVerified: boolean;
  isAnonymous?: boolean;
  linkedAccounts: LinkedAccountResponseV2[];
}

export interface BaseEntityListResponseAuthUserResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AuthUserResponse[];
  start: number;
  end: number;
  total: number;
}

export type UserListResponse = BaseEntityListResponseAuthUserResponse;

export interface UserListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Filter by user name. */
  name?: string;
  /** Filter by external user ID (accountId from linked accounts). */
  externalUserId?: string;
  /** Filter by user email. */
  email?: string;
  /** Filter by user phone number. */
  phoneNumber?: string;
  /** Filter by provider ID (e.g., "google", "apple", "siwe", "credential"). */
  authProviderId?: string;
  /** Filter by wallet client type (for SIWE accounts). */
  walletClientType?: string;
}

export type EntityTypeWALLET = typeof EntityTypeWALLET[keyof typeof EntityTypeWALLET];


export const EntityTypeWALLET = {
  wallet: 'wallet',
} as const;

export interface BaseEntityResponseEntityTypeWALLET {
  id: string;
  object: EntityTypeWALLET;
  createdAt: number;
}

export type WalletResponse = BaseEntityResponseEntityTypeWALLET;

export interface BaseDeleteEntityResponseEntityTypePLAYER {
  id: string;
  object: EntityTypePLAYER;
  deleted: boolean;
}

export type UserDeleteResponse = BaseDeleteEntityResponseEntityTypePLAYER;

export interface SmartAccountData {
  implementationType: string;
  factoryAddress?: string;
  implementationAddress: string;
  salt?: string;
  deployedTx?: string;
  deployedAt?: number;
  active: boolean;
}

export interface PasskeyEnv {
  name?: string;
  os?: string;
  osVersion?: string;
  device?: string;
}

export interface RecoveryMethodDetails {
  passkeyId?: string;
  passkeyEnv?: PasskeyEnv;
}

/**
 * Indicates key custody: "Developer" for server-managed keys (WALLTEE), "User" for user-managed keys (DB).
 */
export type PregenerateAccountResponseCustody = typeof PregenerateAccountResponseCustody[keyof typeof PregenerateAccountResponseCustody];


export const PregenerateAccountResponseCustody = {
  Developer: 'Developer',
  User: 'User',
} as const;

export interface PregenerateAccountResponse {
  id: string;
  wallet: string;
  accountType: string;
  address: string;
  ownerAddress?: string;
  chainType: string;
  chainId?: number;
  createdAt: number;
  updatedAt: number;
  smartAccount?: SmartAccountData;
  recoveryMethod?: string;
  recoveryMethodDetails?: RecoveryMethodDetails;
  /** Indicates key custody: "Developer" for server-managed keys (WALLTEE), "User" for user-managed keys (DB). */
  custody: PregenerateAccountResponseCustody;
  /** The recovery share for the user's embedded signer.
This should be stored securely and provided to the user for account recovery. */
  recoveryShare: string;
  /** User uuid */
  user: string;
}

/**
 * Enum of the supporting third party auth providers.
 */
export type ThirdPartyOAuthProvider = typeof ThirdPartyOAuthProvider[keyof typeof ThirdPartyOAuthProvider];


export const ThirdPartyOAuthProvider = {
  accelbyte: 'accelbyte',
  firebase: 'firebase',
  lootlocker: 'lootlocker',
  playfab: 'playfab',
  supabase: 'supabase',
  custom: 'custom',
  oidc: 'oidc',
  'better-auth': 'better-auth',
} as const;

/**
 * The type of account to pregenerate. "Externally Owned Account", "Smart Account" or "Delegated Account".
Defaults to "Smart Account".
 */
export type PregenerateUserRequestV2AccountType = typeof PregenerateUserRequestV2AccountType[keyof typeof PregenerateUserRequestV2AccountType];


export const PregenerateUserRequestV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * The chain type. "EVM" or "SVM". Defaults to "EVM".
 */
export type PregenerateUserRequestV2ChainType = typeof PregenerateUserRequestV2ChainType[keyof typeof PregenerateUserRequestV2ChainType];


export const PregenerateUserRequestV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export interface PregenerateUserRequestV2 {
  /** The email address of the user to pregenerate.
Required if thirdPartyUserId is not provided. */
  email?: string;
  /** The third-party user ID from an external auth provider (Firebase, Supabase, etc.).
Required if email is not provided. */
  thirdPartyUserId?: string;
  /** The third-party auth provider. Required when thirdPartyUserId is provided. */
  thirdPartyProvider?: ThirdPartyOAuthProvider;
  /** The type of account to pregenerate. "Externally Owned Account", "Smart Account" or "Delegated Account".
Defaults to "Smart Account". */
  accountType?: PregenerateUserRequestV2AccountType;
  /** The chain type. "EVM" or "SVM". Defaults to "EVM". */
  chainType?: PregenerateUserRequestV2ChainType;
  /** The chain ID. Required for Smart Account and Delegated Account types.
Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** The implementation type for Smart Account or Delegated Account (e.g. Calibur, UpgradeableV6).
Required for Smart Account and Delegated Account types. */
  implementationType?: string;
}

export type PolicyV2Scope = typeof PolicyV2Scope[keyof typeof PolicyV2Scope];


export const PolicyV2Scope = {
  project: 'project',
  account: 'account',
} as const;

export type PolicyV2Action = typeof PolicyV2Action[keyof typeof PolicyV2Action];


export const PolicyV2Action = {
  accept: 'accept',
  reject: 'reject',
} as const;

export type EvmCriteriaTypeEVMADDRESS = typeof EvmCriteriaTypeEVMADDRESS[keyof typeof EvmCriteriaTypeEVMADDRESS];


export const EvmCriteriaTypeEVMADDRESS = {
  evmAddress: 'evmAddress',
} as const;

export type CriteriaOperatorIN = typeof CriteriaOperatorIN[keyof typeof CriteriaOperatorIN];


export const CriteriaOperatorIN = {
  in: 'in',
} as const;

export type CriteriaOperatorNOTIN = typeof CriteriaOperatorNOTIN[keyof typeof CriteriaOperatorNOTIN];


export const CriteriaOperatorNOTIN = {
  not_in: 'not in',
} as const;

export type EvmCriteriaType = typeof EvmCriteriaType[keyof typeof EvmCriteriaType];


export const EvmCriteriaType = {
  evmAddress: 'evmAddress',
  ethValue: 'ethValue',
  evmNetwork: 'evmNetwork',
  evmMessage: 'evmMessage',
  evmData: 'evmData',
  evmTypedDataVerifyingContract: 'evmTypedDataVerifyingContract',
  evmTypedDataField: 'evmTypedDataField',
  netUSDChange: 'netUSDChange',
} as const;

export type SolanaCriteriaType = typeof SolanaCriteriaType[keyof typeof SolanaCriteriaType];


export const SolanaCriteriaType = {
  solAddress: 'solAddress',
  solValue: 'solValue',
  splAddress: 'splAddress',
  splValue: 'splValue',
  mintAddress: 'mintAddress',
  solData: 'solData',
  programId: 'programId',
  solNetwork: 'solNetwork',
  solMessage: 'solMessage',
} as const;

export const CriteriaType = {...EvmCriteriaType,...SolanaCriteriaType,} as const
export type CriteriaType = typeof CriteriaType[keyof typeof CriteriaType];

export type CriteriaOperator = typeof CriteriaOperator[keyof typeof CriteriaOperator];


export const CriteriaOperator = {
  in: 'in',
  not_in: 'not in',
  '<': '<',
  '<=': '<=',
  '>': '>',
  '>=': '>=',
  '==': '==',
  match: 'match',
} as const;

export const EvmAddressCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorNOTIN,} as const
export interface EvmAddressCriterion {
  type: EvmCriteriaTypeEVMADDRESS;
  operator: typeof EvmAddressCriterionOperator[keyof typeof EvmAddressCriterionOperator];
  addresses: string[];
}

export type EvmCriteriaTypeETHVALUE = typeof EvmCriteriaTypeETHVALUE[keyof typeof EvmCriteriaTypeETHVALUE];


export const EvmCriteriaTypeETHVALUE = {
  ethValue: 'ethValue',
} as const;

export type CriteriaOperatorLESSTHANOREQUAL = typeof CriteriaOperatorLESSTHANOREQUAL[keyof typeof CriteriaOperatorLESSTHANOREQUAL];


export const CriteriaOperatorLESSTHANOREQUAL = {
  '<=': '<=',
} as const;

export type CriteriaOperatorGREATERTHANOREQUAL = typeof CriteriaOperatorGREATERTHANOREQUAL[keyof typeof CriteriaOperatorGREATERTHANOREQUAL];


export const CriteriaOperatorGREATERTHANOREQUAL = {
  '>=': '>=',
} as const;

export type CriteriaOperatorLESSTHAN = typeof CriteriaOperatorLESSTHAN[keyof typeof CriteriaOperatorLESSTHAN];


export const CriteriaOperatorLESSTHAN = {
  '<': '<',
} as const;

export type CriteriaOperatorGREATERTHAN = typeof CriteriaOperatorGREATERTHAN[keyof typeof CriteriaOperatorGREATERTHAN];


export const CriteriaOperatorGREATERTHAN = {
  '>': '>',
} as const;

export const EthValueCriterionOperator = {...CriteriaOperatorLESSTHANOREQUAL,...CriteriaOperatorGREATERTHANOREQUAL,...CriteriaOperatorLESSTHAN,...CriteriaOperatorGREATERTHAN,} as const
export interface EthValueCriterion {
  type: EvmCriteriaTypeETHVALUE;
  operator: typeof EthValueCriterionOperator[keyof typeof EthValueCriterionOperator];
  ethValue: string;
}

export type EvmCriteriaTypeEVMNETWORK = typeof EvmCriteriaTypeEVMNETWORK[keyof typeof EvmCriteriaTypeEVMNETWORK];


export const EvmCriteriaTypeEVMNETWORK = {
  evmNetwork: 'evmNetwork',
} as const;

export const EvmNetworkCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorNOTIN,} as const
export interface EvmNetworkCriterion {
  type: EvmCriteriaTypeEVMNETWORK;
  operator: typeof EvmNetworkCriterionOperator[keyof typeof EvmNetworkCriterionOperator];
  chainIds: number[];
}

export type EvmCriteriaTypeEVMMESSAGE = typeof EvmCriteriaTypeEVMMESSAGE[keyof typeof EvmCriteriaTypeEVMMESSAGE];


export const EvmCriteriaTypeEVMMESSAGE = {
  evmMessage: 'evmMessage',
} as const;

export type CriteriaOperatorMATCH = typeof CriteriaOperatorMATCH[keyof typeof CriteriaOperatorMATCH];


export const CriteriaOperatorMATCH = {
  match: 'match',
} as const;

export interface EvmMessageCriterion {
  type: EvmCriteriaTypeEVMMESSAGE;
  operator: CriteriaOperatorMATCH;
  pattern: string;
}

export type EvmCriteriaTypeEVMDATA = typeof EvmCriteriaTypeEVMDATA[keyof typeof EvmCriteriaTypeEVMDATA];


export const EvmCriteriaTypeEVMDATA = {
  evmData: 'evmData',
} as const;

/**
 * Construct a type with a set of properties K of type T
 */
export interface RecordStringUnknown {[key: string]: unknown}

export interface EvmDataCriterion {
  type: EvmCriteriaTypeEVMDATA;
  operator: CriteriaOperator;
  abi: string;
  functionName: string;
  args?: RecordStringUnknown;
}

export type EvmCriteriaTypeEVMTYPEDDATAVERIFYINGCONTRACT = typeof EvmCriteriaTypeEVMTYPEDDATAVERIFYINGCONTRACT[keyof typeof EvmCriteriaTypeEVMTYPEDDATAVERIFYINGCONTRACT];


export const EvmCriteriaTypeEVMTYPEDDATAVERIFYINGCONTRACT = {
  evmTypedDataVerifyingContract: 'evmTypedDataVerifyingContract',
} as const;

export const EvmTypedDataVerifyingContractCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorNOTIN,} as const
export interface EvmTypedDataVerifyingContractCriterion {
  type: EvmCriteriaTypeEVMTYPEDDATAVERIFYINGCONTRACT;
  operator: typeof EvmTypedDataVerifyingContractCriterionOperator[keyof typeof EvmTypedDataVerifyingContractCriterionOperator];
  addresses: string[];
}

export type EvmCriteriaTypeEVMTYPEDDATAFIELD = typeof EvmCriteriaTypeEVMTYPEDDATAFIELD[keyof typeof EvmCriteriaTypeEVMTYPEDDATAFIELD];


export const EvmCriteriaTypeEVMTYPEDDATAFIELD = {
  evmTypedDataField: 'evmTypedDataField',
} as const;

export const EvmTypedDataFieldCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorLESSTHANOREQUAL,...CriteriaOperatorMATCH,} as const
export interface EvmTypedDataFieldCriterion {
  type: EvmCriteriaTypeEVMTYPEDDATAFIELD;
  operator: typeof EvmTypedDataFieldCriterionOperator[keyof typeof EvmTypedDataFieldCriterionOperator];
  fieldPath: string;
  values?: string[];
  value?: string;
}

export type EvmCriteriaTypeNETUSDCHANGE = typeof EvmCriteriaTypeNETUSDCHANGE[keyof typeof EvmCriteriaTypeNETUSDCHANGE];


export const EvmCriteriaTypeNETUSDCHANGE = {
  netUSDChange: 'netUSDChange',
} as const;

export const NetUSDChangeCriterionOperator = {...CriteriaOperatorLESSTHANOREQUAL,...CriteriaOperatorGREATERTHANOREQUAL,} as const
export interface NetUSDChangeCriterion {
  type: EvmCriteriaTypeNETUSDCHANGE;
  operator: typeof NetUSDChangeCriterionOperator[keyof typeof NetUSDChangeCriterionOperator];
  usdValue: string;
}

export type SolanaCriteriaTypeSOLADDRESS = typeof SolanaCriteriaTypeSOLADDRESS[keyof typeof SolanaCriteriaTypeSOLADDRESS];


export const SolanaCriteriaTypeSOLADDRESS = {
  solAddress: 'solAddress',
} as const;

export const SolAddressCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorNOTIN,} as const
export interface SolAddressCriterion {
  type: SolanaCriteriaTypeSOLADDRESS;
  operator: typeof SolAddressCriterionOperator[keyof typeof SolAddressCriterionOperator];
  addresses: string[];
}

export type SolanaCriteriaTypeSOLVALUE = typeof SolanaCriteriaTypeSOLVALUE[keyof typeof SolanaCriteriaTypeSOLVALUE];


export const SolanaCriteriaTypeSOLVALUE = {
  solValue: 'solValue',
} as const;

export const SolValueCriterionOperator = {...CriteriaOperatorLESSTHANOREQUAL,...CriteriaOperatorGREATERTHANOREQUAL,} as const
export interface SolValueCriterion {
  type: SolanaCriteriaTypeSOLVALUE;
  operator: typeof SolValueCriterionOperator[keyof typeof SolValueCriterionOperator];
  value: string;
}

export type SolanaCriteriaTypeSPLADDRESS = typeof SolanaCriteriaTypeSPLADDRESS[keyof typeof SolanaCriteriaTypeSPLADDRESS];


export const SolanaCriteriaTypeSPLADDRESS = {
  splAddress: 'splAddress',
} as const;

export const SplAddressCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorNOTIN,} as const
export interface SplAddressCriterion {
  type: SolanaCriteriaTypeSPLADDRESS;
  operator: typeof SplAddressCriterionOperator[keyof typeof SplAddressCriterionOperator];
  addresses: string[];
}

export type SolanaCriteriaTypeSPLVALUE = typeof SolanaCriteriaTypeSPLVALUE[keyof typeof SolanaCriteriaTypeSPLVALUE];


export const SolanaCriteriaTypeSPLVALUE = {
  splValue: 'splValue',
} as const;

export const SplValueCriterionOperator = {...CriteriaOperatorLESSTHANOREQUAL,...CriteriaOperatorGREATERTHANOREQUAL,} as const
export interface SplValueCriterion {
  type: SolanaCriteriaTypeSPLVALUE;
  operator: typeof SplValueCriterionOperator[keyof typeof SplValueCriterionOperator];
  value: string;
}

export type SolanaCriteriaTypeMINTADDRESS = typeof SolanaCriteriaTypeMINTADDRESS[keyof typeof SolanaCriteriaTypeMINTADDRESS];


export const SolanaCriteriaTypeMINTADDRESS = {
  mintAddress: 'mintAddress',
} as const;

export type CriteriaOperatorEQUAL = typeof CriteriaOperatorEQUAL[keyof typeof CriteriaOperatorEQUAL];


export const CriteriaOperatorEQUAL = {
  '==': '==',
} as const;

export const MintAddressCriterionOperator = {...CriteriaOperatorEQUAL,...CriteriaOperatorIN,} as const
export interface MintAddressCriterion {
  type: SolanaCriteriaTypeMINTADDRESS;
  operator: typeof MintAddressCriterionOperator[keyof typeof MintAddressCriterionOperator];
  addresses: string[];
}

export type SolanaCriteriaTypeSOLDATA = typeof SolanaCriteriaTypeSOLDATA[keyof typeof SolanaCriteriaTypeSOLDATA];


export const SolanaCriteriaTypeSOLDATA = {
  solData: 'solData',
} as const;

export interface SolDataCriterion {
  type: SolanaCriteriaTypeSOLDATA;
  operator: CriteriaOperator;
  idl: string;
  instructionName: string;
  args?: RecordStringUnknown;
}

export type SolanaCriteriaTypePROGRAMID = typeof SolanaCriteriaTypePROGRAMID[keyof typeof SolanaCriteriaTypePROGRAMID];


export const SolanaCriteriaTypePROGRAMID = {
  programId: 'programId',
} as const;

export const ProgramIdCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorNOTIN,} as const
export interface ProgramIdCriterion {
  type: SolanaCriteriaTypePROGRAMID;
  operator: typeof ProgramIdCriterionOperator[keyof typeof ProgramIdCriterionOperator];
  programIds: string[];
}

export type SolanaCriteriaTypeSOLNETWORK = typeof SolanaCriteriaTypeSOLNETWORK[keyof typeof SolanaCriteriaTypeSOLNETWORK];


export const SolanaCriteriaTypeSOLNETWORK = {
  solNetwork: 'solNetwork',
} as const;

export const SolNetworkCriterionOperator = {...CriteriaOperatorIN,...CriteriaOperatorNOTIN,} as const
export interface SolNetworkCriterion {
  type: SolanaCriteriaTypeSOLNETWORK;
  operator: typeof SolNetworkCriterionOperator[keyof typeof SolNetworkCriterionOperator];
  networks: string[];
}

export type SolanaCriteriaTypeSOLMESSAGE = typeof SolanaCriteriaTypeSOLMESSAGE[keyof typeof SolanaCriteriaTypeSOLMESSAGE];


export const SolanaCriteriaTypeSOLMESSAGE = {
  solMessage: 'solMessage',
} as const;

export interface SolMessageCriterion {
  type: SolanaCriteriaTypeSOLMESSAGE;
  operator: CriteriaOperatorMATCH;
  pattern: string;
}

export type PolicyV2Criterion = EvmAddressCriterion | EthValueCriterion | EvmNetworkCriterion | EvmMessageCriterion | EvmDataCriterion | EvmTypedDataVerifyingContractCriterion | EvmTypedDataFieldCriterion | NetUSDChangeCriterion | SolAddressCriterion | SolValueCriterion | SplAddressCriterion | SplValueCriterion | MintAddressCriterion | SolDataCriterion | ProgramIdCriterion | SolNetworkCriterion | SolMessageCriterion;

export type EntityTypePOLICYV2RULE = typeof EntityTypePOLICYV2RULE[keyof typeof EntityTypePOLICYV2RULE];


export const EntityTypePOLICYV2RULE = {
  policyV2Rule: 'policyV2Rule',
} as const;

export interface PolicyV2RuleResponse {
  id: string;
  object: EntityTypePOLICYV2RULE;
  createdAt: number;
  /** The action to take when this rule matches. */
  action: PolicyV2Action;
  /** The operation this rule applies to.
EVM: signEvmTransaction, sendEvmTransaction, signEvmTypedData, signEvmMessage, signEvmHash
Solana: signSolTransaction, sendSolTransaction, signSolMessage */
  operation: string;
  /** Array of criteria to match for this rule. All criteria must match (AND logic). */
  criteria: PolicyV2Criterion[];
}

export type EntityTypePOLICYV2 = typeof EntityTypePOLICYV2[keyof typeof EntityTypePOLICYV2];


export const EntityTypePOLICYV2 = {
  policyV2: 'policyV2',
} as const;

export interface PolicyV2Response {
  id: string;
  object: EntityTypePOLICYV2;
  createdAt: number;
  /** The scope of the policy. */
  scope: PolicyV2Scope;
  /**
   * A description of what this policy does.
   * @nullable
   */
  description: string | null;
  /**
   * The account ID for account-scoped policies.
   * @nullable
   */
  accountId: string | null;
  /** Whether the policy is enabled. */
  enabled: boolean;
  /** Priority of the policy. */
  priority: number;
  /** The rules that make up this policy. Rules are processed sequentially until a match occurs. */
  rules: PolicyV2RuleResponse[];
}

export interface PolicyV2ListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: PolicyV2Response[];
  start: number;
  end: number;
  total: number;
}

/**
 * Filter by scope.
 */
export type PolicyV2ListQueriesScope = typeof PolicyV2ListQueriesScope[keyof typeof PolicyV2ListQueriesScope];


export const PolicyV2ListQueriesScope = {
  project: 'project',
  account: 'account',
} as const;

export interface PolicyV2ListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Filter by scope. */
  scope?: PolicyV2ListQueriesScope;
  /** Filter by enabled status. */
  enabled?: boolean;
  /** Filter by account ID (for account-scoped policies). */
  accountId?: string;
}

/**
 * The type of criterion.
 */
export type EvmAddressCriterionRequestType = typeof EvmAddressCriterionRequestType[keyof typeof EvmAddressCriterionRequestType];


export const EvmAddressCriterionRequestType = {
  evmAddress: 'evmAddress',
} as const;

/**
 * The operator to use for comparison.
 */
export type EvmAddressCriterionRequestOperator = typeof EvmAddressCriterionRequestOperator[keyof typeof EvmAddressCriterionRequestOperator];


export const EvmAddressCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
} as const;

/**
 * EVM Address criterion - validates recipient addresses.
Operators: "in", "not in"
 */
export interface EvmAddressCriterionRequest {
  /** The type of criterion. */
  type: EvmAddressCriterionRequestType;
  /** The operator to use for comparison. */
  operator: EvmAddressCriterionRequestOperator;
  /** List of EVM addresses (hex format with 0x prefix). */
  addresses: string[];
}

/**
 * The type of criterion.
 */
export type EthValueCriterionRequestType = typeof EthValueCriterionRequestType[keyof typeof EthValueCriterionRequestType];


export const EthValueCriterionRequestType = {
  ethValue: 'ethValue',
} as const;

/**
 * The operator to use for comparison.
 */
export type EthValueCriterionRequestOperator = typeof EthValueCriterionRequestOperator[keyof typeof EthValueCriterionRequestOperator];


export const EthValueCriterionRequestOperator = {
  '<=': '<=',
  '>=': '>=',
  '<': '<',
  '>': '>',
} as const;

/**
 * ETH Value criterion - validates native asset amounts in wei.
Operators: "<=", ">=", "<", ">"
 */
export interface EthValueCriterionRequest {
  /** The type of criterion. */
  type: EthValueCriterionRequestType;
  /** The operator to use for comparison. */
  operator: EthValueCriterionRequestOperator;
  /** Value in wei as a string. */
  ethValue: string;
}

/**
 * The type of criterion.
 */
export type EvmNetworkCriterionRequestType = typeof EvmNetworkCriterionRequestType[keyof typeof EvmNetworkCriterionRequestType];


export const EvmNetworkCriterionRequestType = {
  evmNetwork: 'evmNetwork',
} as const;

/**
 * The operator to use for comparison.
 */
export type EvmNetworkCriterionRequestOperator = typeof EvmNetworkCriterionRequestOperator[keyof typeof EvmNetworkCriterionRequestOperator];


export const EvmNetworkCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
} as const;

/**
 * EVM Network criterion - validates chain IDs.
Operators: "in", "not in"
 */
export interface EvmNetworkCriterionRequest {
  /** The type of criterion. */
  type: EvmNetworkCriterionRequestType;
  /** The operator to use for comparison. */
  operator: EvmNetworkCriterionRequestOperator;
  /** List of chain IDs. */
  chainIds: number[];
}

/**
 * The type of criterion.
 */
export type EvmMessageCriterionRequestType = typeof EvmMessageCriterionRequestType[keyof typeof EvmMessageCriterionRequestType];


export const EvmMessageCriterionRequestType = {
  evmMessage: 'evmMessage',
} as const;

/**
 * The operator to use for comparison.
 */
export type EvmMessageCriterionRequestOperator = typeof EvmMessageCriterionRequestOperator[keyof typeof EvmMessageCriterionRequestOperator];


export const EvmMessageCriterionRequestOperator = {
  match: 'match',
} as const;

/**
 * EVM Message criterion - validates message content with regex (RE2).
Operators: "match"
 */
export interface EvmMessageCriterionRequest {
  /** The type of criterion. */
  type: EvmMessageCriterionRequestType;
  /** The operator to use for comparison. */
  operator: EvmMessageCriterionRequestOperator;
  /** RE2 regex pattern to match against the message. */
  pattern: string;
}

/**
 * The type of criterion.
 */
export type EvmDataCriterionRequestType = typeof EvmDataCriterionRequestType[keyof typeof EvmDataCriterionRequestType];


export const EvmDataCriterionRequestType = {
  evmData: 'evmData',
} as const;

/**
 * The operator to use for comparison.
 */
export type EvmDataCriterionRequestOperator = typeof EvmDataCriterionRequestOperator[keyof typeof EvmDataCriterionRequestOperator];


export const EvmDataCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
  '<': '<',
  '<=': '<=',
  '>': '>',
  '>=': '>=',
  '==': '==',
  match: 'match',
} as const;

/**
 * EVM Data criterion - validates transaction calldata via ABI.
Operators: "in", "not in", "<", "<=", ">", ">=", "==", "match"
 */
export interface EvmDataCriterionRequest {
  /** The type of criterion. */
  type: EvmDataCriterionRequestType;
  /** The operator to use for comparison. */
  operator: EvmDataCriterionRequestOperator;
  /** Contract ABI as JSON string. */
  abi: string;
  /** Function name to match. */
  functionName: string;
  /** Argument constraints. */
  args?: RecordStringUnknown;
}

/**
 * The type of criterion.
 */
export type EvmTypedDataVerifyingContractCriterionRequestType = typeof EvmTypedDataVerifyingContractCriterionRequestType[keyof typeof EvmTypedDataVerifyingContractCriterionRequestType];


export const EvmTypedDataVerifyingContractCriterionRequestType = {
  evmTypedDataVerifyingContract: 'evmTypedDataVerifyingContract',
} as const;

/**
 * The operator to use for comparison.
 */
export type EvmTypedDataVerifyingContractCriterionRequestOperator = typeof EvmTypedDataVerifyingContractCriterionRequestOperator[keyof typeof EvmTypedDataVerifyingContractCriterionRequestOperator];


export const EvmTypedDataVerifyingContractCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
} as const;

/**
 * EVM Typed Data Verifying Contract criterion - validates EIP-712 domain contract.
Operators: "in", "not in"
 */
export interface EvmTypedDataVerifyingContractCriterionRequest {
  /** The type of criterion. */
  type: EvmTypedDataVerifyingContractCriterionRequestType;
  /** The operator to use for comparison. */
  operator: EvmTypedDataVerifyingContractCriterionRequestOperator;
  /** List of verifying contract addresses. */
  addresses: string[];
}

/**
 * The type of criterion.
 */
export type EvmTypedDataFieldCriterionRequestType = typeof EvmTypedDataFieldCriterionRequestType[keyof typeof EvmTypedDataFieldCriterionRequestType];


export const EvmTypedDataFieldCriterionRequestType = {
  evmTypedDataField: 'evmTypedDataField',
} as const;

/**
 * The operator to use for comparison.
 */
export type EvmTypedDataFieldCriterionRequestOperator = typeof EvmTypedDataFieldCriterionRequestOperator[keyof typeof EvmTypedDataFieldCriterionRequestOperator];


export const EvmTypedDataFieldCriterionRequestOperator = {
  in: 'in',
  '<=': '<=',
  match: 'match',
} as const;

/**
 * EVM Typed Data Field criterion - validates EIP-712 field values.
Operators: "in", "<=", "match"
 */
export interface EvmTypedDataFieldCriterionRequest {
  /** The type of criterion. */
  type: EvmTypedDataFieldCriterionRequestType;
  /** The operator to use for comparison. */
  operator: EvmTypedDataFieldCriterionRequestOperator;
  /** Dot-notation path to field. */
  fieldPath: string;
  /** Values for "in" operator. */
  values?: string[];
  /** Value for "<=" or "match" operators. */
  value?: string;
}

/**
 * The type of criterion.
 */
export type NetUSDChangeCriterionRequestType = typeof NetUSDChangeCriterionRequestType[keyof typeof NetUSDChangeCriterionRequestType];


export const NetUSDChangeCriterionRequestType = {
  netUSDChange: 'netUSDChange',
} as const;

/**
 * The operator to use for comparison.
 */
export type NetUSDChangeCriterionRequestOperator = typeof NetUSDChangeCriterionRequestOperator[keyof typeof NetUSDChangeCriterionRequestOperator];


export const NetUSDChangeCriterionRequestOperator = {
  '<=': '<=',
  '>=': '>=',
} as const;

/**
 * Net USD Change criterion - validates USD exposure limits (mainnet only).
Operators: "<=", ">="
 */
export interface NetUSDChangeCriterionRequest {
  /** The type of criterion. */
  type: NetUSDChangeCriterionRequestType;
  /** The operator to use for comparison. */
  operator: NetUSDChangeCriterionRequestOperator;
  /** USD value as string. */
  usdValue: string;
}

/**
 * The type of criterion.
 */
export type SolAddressCriterionRequestType = typeof SolAddressCriterionRequestType[keyof typeof SolAddressCriterionRequestType];


export const SolAddressCriterionRequestType = {
  solAddress: 'solAddress',
} as const;

/**
 * The operator to use for comparison.
 */
export type SolAddressCriterionRequestOperator = typeof SolAddressCriterionRequestOperator[keyof typeof SolAddressCriterionRequestOperator];


export const SolAddressCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
} as const;

/**
 * Solana Address criterion - validates native SOL transfer recipients.
Operators: "in", "not in"
 */
export interface SolAddressCriterionRequest {
  /** The type of criterion. */
  type: SolAddressCriterionRequestType;
  /** The operator to use for comparison. */
  operator: SolAddressCriterionRequestOperator;
  /** List of Solana addresses (Base58). */
  addresses: string[];
}

/**
 * The type of criterion.
 */
export type SolValueCriterionRequestType = typeof SolValueCriterionRequestType[keyof typeof SolValueCriterionRequestType];


export const SolValueCriterionRequestType = {
  solValue: 'solValue',
} as const;

/**
 * The operator to use for comparison.
 */
export type SolValueCriterionRequestOperator = typeof SolValueCriterionRequestOperator[keyof typeof SolValueCriterionRequestOperator];


export const SolValueCriterionRequestOperator = {
  '<=': '<=',
  '>=': '>=',
} as const;

/**
 * SOL Value criterion - validates SOL amounts in lamports.
Operators: "<=", ">="
 */
export interface SolValueCriterionRequest {
  /** The type of criterion. */
  type: SolValueCriterionRequestType;
  /** The operator to use for comparison. */
  operator: SolValueCriterionRequestOperator;
  /** Value in lamports as string. */
  value: string;
}

/**
 * The type of criterion.
 */
export type SplAddressCriterionRequestType = typeof SplAddressCriterionRequestType[keyof typeof SplAddressCriterionRequestType];


export const SplAddressCriterionRequestType = {
  splAddress: 'splAddress',
} as const;

/**
 * The operator to use for comparison.
 */
export type SplAddressCriterionRequestOperator = typeof SplAddressCriterionRequestOperator[keyof typeof SplAddressCriterionRequestOperator];


export const SplAddressCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
} as const;

/**
 * SPL Address criterion - validates SPL token recipients.
Operators: "in", "not in"
 */
export interface SplAddressCriterionRequest {
  /** The type of criterion. */
  type: SplAddressCriterionRequestType;
  /** The operator to use for comparison. */
  operator: SplAddressCriterionRequestOperator;
  /** List of recipient addresses (Base58). */
  addresses: string[];
}

/**
 * The type of criterion.
 */
export type SplValueCriterionRequestType = typeof SplValueCriterionRequestType[keyof typeof SplValueCriterionRequestType];


export const SplValueCriterionRequestType = {
  splValue: 'splValue',
} as const;

/**
 * The operator to use for comparison.
 */
export type SplValueCriterionRequestOperator = typeof SplValueCriterionRequestOperator[keyof typeof SplValueCriterionRequestOperator];


export const SplValueCriterionRequestOperator = {
  '<=': '<=',
  '>=': '>=',
} as const;

/**
 * SPL Value criterion - validates SPL token amounts.
Operators: "<=", ">="
 */
export interface SplValueCriterionRequest {
  /** The type of criterion. */
  type: SplValueCriterionRequestType;
  /** The operator to use for comparison. */
  operator: SplValueCriterionRequestOperator;
  /** Token amount as string. */
  value: string;
}

/**
 * The type of criterion.
 */
export type MintAddressCriterionRequestType = typeof MintAddressCriterionRequestType[keyof typeof MintAddressCriterionRequestType];


export const MintAddressCriterionRequestType = {
  mintAddress: 'mintAddress',
} as const;

/**
 * The operator to use for comparison.
 */
export type MintAddressCriterionRequestOperator = typeof MintAddressCriterionRequestOperator[keyof typeof MintAddressCriterionRequestOperator];


export const MintAddressCriterionRequestOperator = {
  '==': '==',
  in: 'in',
} as const;

/**
 * Mint Address criterion - validates token mint addresses.
Operators: "==", "in"
 */
export interface MintAddressCriterionRequest {
  /** The type of criterion. */
  type: MintAddressCriterionRequestType;
  /** The operator to use for comparison. */
  operator: MintAddressCriterionRequestOperator;
  /** List of mint addresses (Base58). */
  addresses: string[];
}

/**
 * The type of criterion.
 */
export type SolDataCriterionRequestType = typeof SolDataCriterionRequestType[keyof typeof SolDataCriterionRequestType];


export const SolDataCriterionRequestType = {
  solData: 'solData',
} as const;

/**
 * The operator to use for comparison.
 */
export type SolDataCriterionRequestOperator = typeof SolDataCriterionRequestOperator[keyof typeof SolDataCriterionRequestOperator];


export const SolDataCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
  '<=': '<=',
  '>=': '>=',
  '==': '==',
  match: 'match',
} as const;

/**
 * Solana Data criterion - validates instruction params via Anchor IDL.
Operators: "in", "not in", "<=", ">=", "==", "match"
 */
export interface SolDataCriterionRequest {
  /** The type of criterion. */
  type: SolDataCriterionRequestType;
  /** The operator to use for comparison. */
  operator: SolDataCriterionRequestOperator;
  /** Anchor IDL JSON (v0.30+). */
  idl: string;
  /** Instruction name. */
  instructionName: string;
  /** Argument constraints. */
  args?: RecordStringUnknown;
}

/**
 * The type of criterion.
 */
export type ProgramIdCriterionRequestType = typeof ProgramIdCriterionRequestType[keyof typeof ProgramIdCriterionRequestType];


export const ProgramIdCriterionRequestType = {
  programId: 'programId',
} as const;

/**
 * The operator to use for comparison.
 */
export type ProgramIdCriterionRequestOperator = typeof ProgramIdCriterionRequestOperator[keyof typeof ProgramIdCriterionRequestOperator];


export const ProgramIdCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
} as const;

/**
 * Program ID criterion - validates Solana program IDs.
Operators: "in", "not in"
 */
export interface ProgramIdCriterionRequest {
  /** The type of criterion. */
  type: ProgramIdCriterionRequestType;
  /** The operator to use for comparison. */
  operator: ProgramIdCriterionRequestOperator;
  /** List of program IDs (Base58). */
  programIds: string[];
}

/**
 * The type of criterion.
 */
export type SolNetworkCriterionRequestType = typeof SolNetworkCriterionRequestType[keyof typeof SolNetworkCriterionRequestType];


export const SolNetworkCriterionRequestType = {
  solNetwork: 'solNetwork',
} as const;

/**
 * The operator to use for comparison.
 */
export type SolNetworkCriterionRequestOperator = typeof SolNetworkCriterionRequestOperator[keyof typeof SolNetworkCriterionRequestOperator];


export const SolNetworkCriterionRequestOperator = {
  in: 'in',
  not_in: 'not in',
} as const;

/**
 * Solana Network criterion - validates Solana network.
Operators: "in", "not in"
 */
export interface SolNetworkCriterionRequest {
  /** The type of criterion. */
  type: SolNetworkCriterionRequestType;
  /** The operator to use for comparison. */
  operator: SolNetworkCriterionRequestOperator;
  /** List of networks: "mainnet-beta", "devnet", "testnet". */
  networks: string[];
}

/**
 * The type of criterion.
 */
export type SolMessageCriterionRequestType = typeof SolMessageCriterionRequestType[keyof typeof SolMessageCriterionRequestType];


export const SolMessageCriterionRequestType = {
  solMessage: 'solMessage',
} as const;

/**
 * The operator to use for comparison.
 */
export type SolMessageCriterionRequestOperator = typeof SolMessageCriterionRequestOperator[keyof typeof SolMessageCriterionRequestOperator];


export const SolMessageCriterionRequestOperator = {
  match: 'match',
} as const;

/**
 * Solana Message criterion - validates message content with regex.
Operators: "match"
 */
export interface SolMessageCriterionRequest {
  /** The type of criterion. */
  type: SolMessageCriterionRequestType;
  /** The operator to use for comparison. */
  operator: SolMessageCriterionRequestOperator;
  /** RE2 regex pattern. */
  pattern: string;
}

/**
 * Union of all criterion request types.
 */
export type PolicyV2CriterionRequest = EvmAddressCriterionRequest | EthValueCriterionRequest | EvmNetworkCriterionRequest | EvmMessageCriterionRequest | EvmDataCriterionRequest | EvmTypedDataVerifyingContractCriterionRequest | EvmTypedDataFieldCriterionRequest | NetUSDChangeCriterionRequest | SolAddressCriterionRequest | SolValueCriterionRequest | SplAddressCriterionRequest | SplValueCriterionRequest | MintAddressCriterionRequest | SolDataCriterionRequest | ProgramIdCriterionRequest | SolNetworkCriterionRequest | SolMessageCriterionRequest;

/**
 * The action to take when this rule matches.
 */
export type CreatePolicyV2RuleRequestAction = typeof CreatePolicyV2RuleRequestAction[keyof typeof CreatePolicyV2RuleRequestAction];


export const CreatePolicyV2RuleRequestAction = {
  accept: 'accept',
  reject: 'reject',
} as const;

export interface CreatePolicyV2RuleRequest {
  /** The action to take when this rule matches. */
  action: CreatePolicyV2RuleRequestAction;
  /** The operation this rule applies to.
EVM: signEvmTransaction, sendEvmTransaction, signEvmTypedData, signEvmMessage, signEvmHash
Solana: signSolTransaction, sendSolTransaction, signSolMessage */
  operation: string;
  /** Array of criteria to match for this rule. All criteria must match (AND logic). */
  criteria?: PolicyV2CriterionRequest[];
}

/**
 * The scope of the policy. 'project' applies to all accounts, 'account' applies to a specific account.
 */
export type CreatePolicyV2RequestScope = typeof CreatePolicyV2RequestScope[keyof typeof CreatePolicyV2RequestScope];


export const CreatePolicyV2RequestScope = {
  project: 'project',
  account: 'account',
} as const;

export interface CreatePolicyV2Request {
  /** The scope of the policy. 'project' applies to all accounts, 'account' applies to a specific account. */
  scope: CreatePolicyV2RequestScope;
  /** A description of what this policy does. */
  description?: string;
  /** The account ID for account-scoped policies (starts with acc_). Required when scope is 'account'. */
  accountId?: string;
  /** Whether the policy is enabled. */
  enabled?: boolean;
  /** Priority of the policy. Higher priority policies are evaluated first. */
  priority?: number;
  /** The rules that make up this policy. Rules are processed sequentially until a match occurs. */
  rules: CreatePolicyV2RuleRequest[];
}

/**
 * The object type.
 */
export type EvaluatePolicyV2ResponseObject = typeof EvaluatePolicyV2ResponseObject[keyof typeof EvaluatePolicyV2ResponseObject];


export const EvaluatePolicyV2ResponseObject = {
  policy_evaluation: 'policy_evaluation',
} as const;

export interface EvaluatePolicyV2Response {
  /** The object type. */
  object: EvaluatePolicyV2ResponseObject;
  /** Whether the operation is allowed by the policy. */
  allowed: boolean;
  /** The reason for the policy decision. */
  reason: string;
  /** The operation that was evaluated. */
  operation: string;
  /** The account ID that was evaluated (if any). */
  accountId?: string;
  /** The ID of the policy that matched (if any). */
  matchedPolicyId?: string;
  /** The ID of the rule that matched (if any). */
  matchedRuleId?: string;
}

export interface EvaluatePolicyV2Payload {
  /** Chain ID for EVM operations. */
  chainId?: number;
  /** Recipient address for EVM transaction (hex with 0x prefix). */
  to?: string;
  /** Value in wei for EVM transaction. */
  value?: string;
  /** Transaction data/calldata for EVM transaction (hex with 0x prefix). */
  data?: string;
  /** Verifying contract address for EIP-712 typed data. */
  verifyingContract?: string;
  /** EIP-712 domain object. */
  domain?: RecordStringUnknown;
  /** EIP-712 message object. */
  message?: RecordStringUnknown;
  /** Primary type for EIP-712 typed data. */
  primaryType?: string;
  /** Message content for signEvmMessage. */
  evmMessage?: string;
  /** Solana network: "mainnet-beta", "devnet", "testnet". */
  network?: string;
  /** Recipient addresses for SOL transfers (Base58). */
  recipients?: string[];
  /** SOL amount in lamports. */
  solValue?: string;
  /** Recipient addresses for SPL token transfers (Base58). */
  splRecipients?: string[];
  /** SPL token amount. */
  splValue?: string;
  /** Token mint address (Base58). */
  mintAddress?: string;
  /** Program IDs involved in transaction (Base58). */
  programIds?: string[];
  /** Message content for signSolMessage. */
  solMessage?: string;
  /** Base64-encoded instruction data for Solana programs (includes 8-byte discriminator). */
  instructionData?: string;
}

export interface EvaluatePolicyV2Request {
  /** The signing operation to evaluate.
EVM: signEvmTransaction, sendEvmTransaction, signEvmTypedData, signEvmMessage, signEvmHash
Solana: signSolTransaction, sendSolTransaction, signSolMessage */
  operation: string;
  /** The account ID to evaluate policies for (starts with acc_). If not provided, only project-scoped policies are evaluated. */
  accountId?: string;
  /** The payload to evaluate against policy criteria. Structure depends on the operation type. */
  payload?: EvaluatePolicyV2Payload;
}

export interface UpdatePolicyV2Request {
  /** A description of what this policy does. */
  description?: string;
  /** Whether the policy is enabled. */
  enabled?: boolean;
  /** Priority of the policy. Higher priority policies are evaluated first. */
  priority?: number;
  /** The rules that make up this policy. If provided, replaces all existing rules. */
  rules?: CreatePolicyV2RuleRequest[];
}

export interface PolicyV2DeleteResponse {
  id: string;
  object: EntityTypePOLICYV2;
  deleted: boolean;
}

export interface RecoverV2Response {
  id: string;
  account: string;
  signerAddress: string;
  signer: string;
  share: string;
  isPrimary: boolean;
  createdAt: string;
  user: string;
}

export interface RecoverV2EmbeddedRequest {
  account: string;
}

export interface RegisterEmbeddedV2Request {
  account: string;
  share: string;
}

/**
 * The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account".
 */
export type CreateEmbeddedRequestAccountType = typeof CreateEmbeddedRequestAccountType[keyof typeof CreateEmbeddedRequestAccountType];


export const CreateEmbeddedRequestAccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * The chain type. "EVM" or "SVM".
 */
export type CreateEmbeddedRequestChainType = typeof CreateEmbeddedRequestChainType[keyof typeof CreateEmbeddedRequestChainType];


export const CreateEmbeddedRequestChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export interface CreateEmbeddedRequest {
  /** The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account". */
  accountType: CreateEmbeddedRequestAccountType;
  /** The chain type. "EVM" or "SVM". */
  chainType: CreateEmbeddedRequestChainType;
  /** The wallet address. For EOA: the EOA address. For Smart Account: the owner address (EOA will be created with this address). For Delegated Account: the address for both EOA and Delegated Account. */
  address: string;
  /** The chain ID. Must be a [supported chain](/development/chains). Required for Smart Account and Delegated Account types. */
  chainId?: number;
  /** Specifies the share repositories. Required for creating embedded accounts. */
  share?: string;
  signerUuid?: string;
  /** The type of smart account that will be created (e.g. UpgradeableV6, UpgradeableV5, Calibur, Simple). Defaults to UpgradeableV6 in mainnets. Must support EIP-7702 for Delegated Accounts. */
  implementationType?: string;
}

/**
 * The type of object.
 */
export type BackendWalletResponseObject = typeof BackendWalletResponseObject[keyof typeof BackendWalletResponseObject];


export const BackendWalletResponseObject = {
  backendWallet: 'backendWallet',
} as const;

/**
 * The chain type the wallet is associated with.
 */
export type BackendWalletResponseChainType = typeof BackendWalletResponseChainType[keyof typeof BackendWalletResponseChainType];


export const BackendWalletResponseChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Key custody: always "Developer" for backend wallets (server-managed keys in TEE).
 */
export type BackendWalletResponseCustody = typeof BackendWalletResponseCustody[keyof typeof BackendWalletResponseCustody];


export const BackendWalletResponseCustody = {
  Developer: 'Developer',
} as const;

/**
 * Backend wallet details response.
 */
export interface BackendWalletResponse {
  /** The type of object. */
  object: BackendWalletResponseObject;
  /** The wallet ID (starts with `acc_`). */
  id: string;
  /** The wallet address. */
  address: string;
  /** The chain type the wallet is associated with. */
  chainType: BackendWalletResponseChainType;
  /** Optional name for the wallet. */
  name?: string;
  /** Key custody: always "Developer" for backend wallets (server-managed keys in TEE). */
  custody: BackendWalletResponseCustody;
  /** Creation timestamp (Unix epoch seconds). */
  createdAt: number;
  /** Last updated timestamp (Unix epoch seconds). */
  updatedAt: number;
}

/**
 * The type of object.
 */
export type BackendWalletListResponseObject = typeof BackendWalletListResponseObject[keyof typeof BackendWalletListResponseObject];


export const BackendWalletListResponseObject = {
  list: 'list',
} as const;

/**
 * List of backend wallets response.
 */
export interface BackendWalletListResponse {
  /** The type of object. */
  object: BackendWalletListResponseObject;
  /** API endpoint URL. */
  url: string;
  /** List of backend wallets. */
  data: BackendWalletResponse[];
  /** Starting index. */
  start: number;
  /** Ending index. */
  end: number;
  /** Total number of wallets. */
  total: number;
}

/**
 * Filter by chain type.
 */
export type BackendWalletListQueriesChainType = typeof BackendWalletListQueriesChainType[keyof typeof BackendWalletListQueriesChainType];


export const BackendWalletListQueriesChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Query parameters for listing backend wallets.
 */
export interface BackendWalletListQueries {
  /** Number of wallets to return (default: 10, max: 100). */
  limit?: number;
  /** Number of wallets to skip (for pagination). */
  skip?: number;
  /** Filter by chain type. */
  chainType?: BackendWalletListQueriesChainType;
  /** Filter by wallet address. */
  address?: string;
  /** Filter by wallet name. */
  name?: string;
  /** Filter by associated wallet ID (starts with `pla_`). */
  wallet?: string;
}

/**
 * The type of object.
 */
export type CreateBackendWalletResponseObject = typeof CreateBackendWalletResponseObject[keyof typeof CreateBackendWalletResponseObject];


export const CreateBackendWalletResponseObject = {
  account: 'account',
} as const;

/**
 * The chain type the wallet is associated with.
 */
export type CreateBackendWalletResponseChainType = typeof CreateBackendWalletResponseChainType[keyof typeof CreateBackendWalletResponseChainType];


export const CreateBackendWalletResponseChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Response from creating a new backend wallet account.
 */
export interface CreateBackendWalletResponse {
  /** The type of object. */
  object: CreateBackendWalletResponseObject;
  /** The created account ID (starts with `acc_`). */
  id: string;
  /** The wallet address generated for this account. */
  address: string;
  /** The chain type the wallet is associated with. */
  chainType: CreateBackendWalletResponseChainType;
  /** Creation timestamp (Unix epoch seconds). */
  createdAt: number;
}

/**
 * The chain type for the new wallet.
 */
export type CreateBackendWalletRequestChainType = typeof CreateBackendWalletRequestChainType[keyof typeof CreateBackendWalletRequestChainType];


export const CreateBackendWalletRequestChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Request to create a new backend wallet account.
 */
export interface CreateBackendWalletRequest {
  /** The chain type for the new wallet. */
  chainType: CreateBackendWalletRequestChainType;
  /** The wallet ID to associate with this wallet (starts with `pla_`). */
  wallet?: string;
  /** Optional name for the wallet. */
  name?: string;
}

/**
 * The type of object.
 */
export type DeleteBackendWalletResponseObject = typeof DeleteBackendWalletResponseObject[keyof typeof DeleteBackendWalletResponseObject];


export const DeleteBackendWalletResponseObject = {
  backendWallet: 'backendWallet',
} as const;

/**
 * Response from deleting a backend wallet.
 */
export interface DeleteBackendWalletResponse {
  /** The type of object. */
  object: DeleteBackendWalletResponseObject;
  /** The deleted wallet ID. */
  id: string;
  /** Whether the wallet was deleted. */
  deleted: boolean;
}

/**
 * The type of object.
 */
export type SignResponseObject = typeof SignResponseObject[keyof typeof SignResponseObject];


export const SignResponseObject = {
  signature: 'signature',
} as const;

/**
 * Response from signing data via backend wallet.
 */
export interface SignResponse {
  /** The type of object. */
  object: SignResponseObject;
  /** The account ID that signed the data (starts with `acc_`). */
  account: string;
  /** The signature bytes (hex-encoded). */
  signature: string;
}

/**
 * Request to sign data via backend wallet.
 */
export interface SignRequest {
  /** The data to sign (hex-encoded transaction data or message hash). */
  data: string;
}

/**
 * The type of object.
 */
export type ExportPrivateKeyResponseObject = typeof ExportPrivateKeyResponseObject[keyof typeof ExportPrivateKeyResponseObject];


export const ExportPrivateKeyResponseObject = {
  exportedKey: 'exportedKey',
} as const;

/**
 * Response from exporting a private key with E2E encryption.
 */
export interface ExportPrivateKeyResponse {
  /** The type of object. */
  object: ExportPrivateKeyResponseObject;
  /** The private key encrypted with RSA-OAEP SHA-256 using your ephemeral public key (base64-encoded).
Decrypt using your ephemeral RSA private key. */
  encryptedPrivateKey: string;
}

/**
 * Request to export private key with E2E encryption.
 */
export interface ExportPrivateKeyRequest {
  /** Client's ephemeral RSA-4096 public key for end-to-end encryption (base64 SPKI DER format).
The backend wallet will encrypt the private key using RSA-OAEP SHA-256. */
  encryptionKey: string;
}

/**
 * The type of object.
 */
export type ImportPrivateKeyResponseObject = typeof ImportPrivateKeyResponseObject[keyof typeof ImportPrivateKeyResponseObject];


export const ImportPrivateKeyResponseObject = {
  account: 'account',
} as const;

/**
 * The chain type the wallet is associated with.
 */
export type ImportPrivateKeyResponseChainType = typeof ImportPrivateKeyResponseChainType[keyof typeof ImportPrivateKeyResponseChainType];


export const ImportPrivateKeyResponseChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Response from importing a private key with E2E encryption.
 */
export interface ImportPrivateKeyResponse {
  /** The type of object. */
  object: ImportPrivateKeyResponseObject;
  /** The created account ID (starts with `acc_`). */
  id: string;
  /** The wallet address derived from the imported private key. */
  address: string;
  /** The chain type the wallet is associated with. */
  chainType?: ImportPrivateKeyResponseChainType;
  /** Creation timestamp (Unix epoch seconds). */
  createdAt: number;
}

/**
 * The chain type for the imported wallet.
 */
export type ImportPrivateKeyRequestChainType = typeof ImportPrivateKeyRequestChainType[keyof typeof ImportPrivateKeyRequestChainType];


export const ImportPrivateKeyRequestChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Request to import private key with E2E encryption.
 */
export interface ImportPrivateKeyRequest {
  /** The private key encrypted with RSA-OAEP SHA-256 using the server's static import public key.
Obtain the server's import public key out-of-band (e.g., from SDK or documentation). */
  encryptedPrivateKey: string;
  /** The chain type for the imported wallet. */
  chainType?: ImportPrivateKeyRequestChainType;
  /** The wallet ID to associate with this wallet (starts with `pla_`). */
  wallet?: string;
  /** Optional name for the imported wallet. */
  name?: string;
}

/**
 * The type of object.
 */
export type RegisterWalletSecretResponseObject = typeof RegisterWalletSecretResponseObject[keyof typeof RegisterWalletSecretResponseObject];


export const RegisterWalletSecretResponseObject = {
  walletSecret: 'walletSecret',
} as const;

/**
 * Response from registering a new wallet secret.
 */
export interface RegisterWalletSecretResponse {
  /** The type of object. */
  object: RegisterWalletSecretResponseObject;
  /** The key ID for the registered secret. */
  keyId: string;
  /** Timestamp when the secret was registered (Unix epoch seconds). */
  registeredAt: number;
}

/**
 * Request to register a new wallet secret (authentication key).

Uses provided-key authentication: the walletAuthToken JWT must be signed by
the private key corresponding to the publicKey being registered.
 */
export interface RegisterWalletSecretRequest {
  /** ECDSA P-256 public key for wallet authentication (PEM format).
This will be used to verify X-Wallet-Auth JWT signatures. */
  publicKey: string;
  /** JWT signed with the private key corresponding to publicKey.
This proves possession of the private key without transmitting it.

JWT must include: uris (matching request path), reqHash (SHA-256 of request body),
iat (issued at), nbf (not before), and optionally exp (expiration). */
  walletAuthToken: string;
  /** Key identifier for the secret.
Used to identify this key in X-Wallet-Auth JWT headers. */
  keyId?: string;
}

/**
 * The type of object.
 */
export type RevokeWalletSecretResponseObject = typeof RevokeWalletSecretResponseObject[keyof typeof RevokeWalletSecretResponseObject];


export const RevokeWalletSecretResponseObject = {
  walletSecretRevocation: 'walletSecretRevocation',
} as const;

/**
 * Response from revoking a wallet secret.
 */
export interface RevokeWalletSecretResponse {
  /** The type of object. */
  object: RevokeWalletSecretResponseObject;
  /** The key ID of the revoked secret. */
  keyId: string;
  /** Whether the secret was successfully revoked. */
  revoked: boolean;
  /** Timestamp when the secret was revoked (Unix epoch seconds). */
  revokedAt: number;
}

/**
 * Request to revoke a wallet secret (authentication key).
 */
export interface RevokeWalletSecretRequest {
  /** Key identifier of the secret to revoke. */
  keyId: string;
}

/**
 * The type of object.
 */
export type RotateWalletSecretResponseObject = typeof RotateWalletSecretResponseObject[keyof typeof RotateWalletSecretResponseObject];


export const RotateWalletSecretResponseObject = {
  walletSecretRotation: 'walletSecretRotation',
} as const;

/**
 * Response from rotating a wallet secret.
 */
export interface RotateWalletSecretResponse {
  /** The type of object. */
  object: RotateWalletSecretResponseObject;
  /** Whether the rotation was successful. */
  success: boolean;
  /** Timestamp when the rotation occurred (Unix epoch seconds). */
  rotatedAt: number;
}

/**
 * Request to rotate wallet secret (authentication key).

Uses provided-key authentication: the walletAuthToken JWT must be signed by
the private key corresponding to the newPublicKey being registered.
 */
export interface RotateWalletSecretRequest {
  /** New ECDSA P-256 public key for wallet authentication (PEM format).
This will replace the current wallet secret used for X-Wallet-Auth JWT signing. */
  newPublicKey: string;
  /** JWT signed with the private key corresponding to newPublicKey.
This proves possession of the private key without transmitting it.

JWT must include: uris (matching request path), reqHash (SHA-256 of request body),
iat (issued at), nbf (not before), and optionally exp (expiration). */
  walletAuthToken: string;
  /** Key identifier for the new secret.
Used to identify this key in X-Wallet-Auth JWT headers. */
  newKeyId?: string;
}

/**
 * Indicates key custody: "Developer" for server-managed keys (WALLTEE), "User" for user-managed keys (DB).
 */
export type AccountV2ResponseCustody = typeof AccountV2ResponseCustody[keyof typeof AccountV2ResponseCustody];


export const AccountV2ResponseCustody = {
  Developer: 'Developer',
  User: 'User',
} as const;

export interface AccountV2Response {
  id: string;
  wallet: string;
  accountType: string;
  address: string;
  ownerAddress?: string;
  chainType: string;
  chainId?: number;
  createdAt: number;
  updatedAt: number;
  smartAccount?: SmartAccountData;
  recoveryMethod?: string;
  recoveryMethodDetails?: RecoveryMethodDetails;
  /** Indicates key custody: "Developer" for server-managed keys (WALLTEE), "User" for user-managed keys (DB). */
  custody: AccountV2ResponseCustody;
}

export interface BaseEntityListResponseAccountV2Response {
  object: ResponseTypeLIST;
  url: string;
  data: AccountV2Response[];
  start: number;
  end: number;
  total: number;
}

export type AccountListV2Response = BaseEntityListResponseAccountV2Response;

/**
 * The chain type. Must be either "EVM" or "SVM".
 */
export type AccountListQueriesV2ChainType = typeof AccountListQueriesV2ChainType[keyof typeof AccountListQueriesV2ChainType];


export const AccountListQueriesV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Specifies the type of account. Must be either "Smart Account" or "Externally Owned Account".
 */
export type AccountListQueriesV2AccountType = typeof AccountListQueriesV2AccountType[keyof typeof AccountListQueriesV2AccountType];


export const AccountListQueriesV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * Specifies the key custody of the account. Must be either "Developer" or "User".
 */
export type AccountListQueriesV2Custody = typeof AccountListQueriesV2Custody[keyof typeof AccountListQueriesV2Custody];


export const AccountListQueriesV2Custody = {
  Developer: 'Developer',
  User: 'User',
} as const;

export interface AccountListQueriesV2 {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Specifies the unique user ID (starts with pla_) */
  user?: string;
  /** The chain type. Must be either "EVM" or "SVM". */
  chainType?: AccountListQueriesV2ChainType;
  /** Specifies the type of account. Must be either "Smart Account" or "Externally Owned Account". */
  accountType?: AccountListQueriesV2AccountType;
  /** Specifies the key custody of the account. Must be either "Developer" or "User". */
  custody?: AccountListQueriesV2Custody;
  /** Specifies the account address */
  address?: string;
}

export interface SignerIdResponse {
  id: string;
}

export interface SwitchChainQueriesV2 {
  /** The account ID (starts with acc_) */
  account: string;
  /** The target chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
}

/**
 * The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account".
 */
export type CreateAccountRequestV2AccountType = typeof CreateAccountRequestV2AccountType[keyof typeof CreateAccountRequestV2AccountType];


export const CreateAccountRequestV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * The chain type. "EVM" or "SVM".
 */
export type CreateAccountRequestV2ChainType = typeof CreateAccountRequestV2ChainType[keyof typeof CreateAccountRequestV2ChainType];


export const CreateAccountRequestV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export interface CreateAccountRequestV2 {
  /** The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account". */
  accountType: CreateAccountRequestV2AccountType;
  /** The chain type. "EVM" or "SVM". */
  chainType: CreateAccountRequestV2ChainType;
  address?: string;
  /** The type of smart account that will be created (e.g. UpgradeableV6, UpgradeableV5, Calibur). Defaults to UpgradeableV6 in mainnets. */
  implementationType?: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** ID of the user this account belongs to (starts with `usr_`). If none is provided, a new user will be created. */
  user: string;
  /** ID of the account (starts with `acc_`) to be linked with. Required for accountType "Smart Account". */
  account?: string;
}

export interface DeleteAccountResponse {
  id: string;
  object: EntityTypeACCOUNT;
  deleted: boolean;
}

export type UserProjectRole = typeof UserProjectRole[keyof typeof UserProjectRole];


export const UserProjectRole = {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
} as const;

export type EntityTypeUSER = typeof EntityTypeUSER[keyof typeof EntityTypeUSER];


export const EntityTypeUSER = {
  user: 'user',
} as const;

export interface UserProjectResponse {
  id: string;
  object: EntityTypeUSER;
  createdAt: number;
  updatedAt: number;
  firstName: string;
  lastName: string;
  role: UserProjectRole;
  email: string;
}

export interface UserProjectListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: UserProjectResponse[];
  start: number;
  end: number;
  total: number;
}

export type UserProjectRoleADMIN = typeof UserProjectRoleADMIN[keyof typeof UserProjectRoleADMIN];


export const UserProjectRoleADMIN = {
  ADMIN: 'ADMIN',
} as const;

export type UserProjectRoleMEMBER = typeof UserProjectRoleMEMBER[keyof typeof UserProjectRoleMEMBER];


export const UserProjectRoleMEMBER = {
  MEMBER: 'MEMBER',
} as const;

export const UserProjectCreateRequestRole = {...UserProjectRoleADMIN,...UserProjectRoleMEMBER,} as const
export interface UserProjectCreateRequest {
  /** The role of the user. */
  role?: typeof UserProjectCreateRequestRole[keyof typeof UserProjectCreateRequestRole];
  /** The email of the user to add. */
  email: string;
}

export const UserProjectUpdateRequestRole = {...UserProjectRoleMEMBER,...UserProjectRoleADMIN,} as const
export interface UserProjectUpdateRequest {
  /** The role of the user. */
  role: typeof UserProjectUpdateRequestRole[keyof typeof UserProjectUpdateRequestRole];
}

export interface UserProjectDeleteResponse {
  id: string;
  object: EntityTypeUSER;
  deleted: boolean;
}

export interface ApiKeyResponse {
  id: number;
  createdAt: number;
  token: string;
  name: string;
  livemode: boolean;
}

export interface WebhookResponse {
  /** @nullable */
  webhook: string | null;
  livemode: boolean;
}

export type EntityTypePROJECT = typeof EntityTypePROJECT[keyof typeof EntityTypePROJECT];


export const EntityTypePROJECT = {
  project: 'project',
} as const;

export interface ChildProjectResponse {
  id: string;
  object: EntityTypePROJECT;
  createdAt: number;
  name: string;
}

export interface ChildProjectListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: ChildProjectResponse[];
  start: number;
  end: number;
  total: number;
}

export interface ProjectResponse {
  id: string;
  object: EntityTypePROJECT;
  createdAt: number;
  updatedAt: number;
  name: string;
  apikeys?: ApiKeyResponse[];
  webhook?: WebhookResponse[];
  parentProject?: string;
  childProjects?: ChildProjectListResponse;
  isV2: boolean;
}

export interface ProjectListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: ProjectResponse[];
  start: number;
  end: number;
  total: number;
}

export interface TransactionStat {
  timestamp: string;
  total: number;
  successful: number;
  gasUsed: string;
}

export interface Stat {
  timestamp: string;
  total: number;
}

export type DeviceStat = Stat;

export interface ProjectStatsResponse {
  transactionIntents: TransactionStat[];
  devices: Stat[];
}

export type ProjectStatsRequestTimeFrame = typeof ProjectStatsRequestTimeFrame[keyof typeof ProjectStatsRequestTimeFrame];


export const ProjectStatsRequestTimeFrame = {
  day: 'day',
  week: 'week',
  month: 'month',
  all: 'all',
} as const;

export interface ProjectStatsRequest {
  timeFrame: ProjectStatsRequestTimeFrame;
}

export type PlanChangeType = typeof PlanChangeType[keyof typeof PlanChangeType];


export const PlanChangeType = {
  upgrade: 'upgrade',
  downgrade: 'downgrade',
  none: 'none',
} as const;

export interface Plan {
  id: string;
  name: string;
  price: number;
  is_current: boolean;
  change_type: PlanChangeType;
  legacy?: boolean;
}

export interface PlansResponse {
  plans: Plan[];
}

export type BillingSubscriptionResponsePlan = {
  price: number;
  name: string;
  id: string;
};

export interface BillingSubscriptionResponse {
  currentPeriodEnd?: string;
  currentPeriodStart?: string;
  canceledAt?: string;
  plan: BillingSubscriptionResponsePlan;
}

export type PrivateKeyPolicy = typeof PrivateKeyPolicy[keyof typeof PrivateKeyPolicy];


export const PrivateKeyPolicy = {
  INDIVIDUAL: 'INDIVIDUAL',
  PROJECT: 'PROJECT',
} as const;

export interface CreateProjectRequest {
  /**
   * Name of the project.
   * @minLength 1
   * @maxLength 256
   */
  name: string;
  /** The private key policyfor the project. */
  pkPolicy?: PrivateKeyPolicy;
}

export interface UpdateProjectRequest {
  /**
   * Name of the project.
   * @minLength 1
   * @maxLength 256
   */
  name: string;
}

export interface AllowedOriginsResponse {
  allowedOrigins: string[];
}

export interface AllowedOriginsRequest {
  allowedOrigins: string[];
}

export type EntityTypeSMTPCONFIG = typeof EntityTypeSMTPCONFIG[keyof typeof EntityTypeSMTPCONFIG];


export const EntityTypeSMTPCONFIG = {
  smtpConfig: 'smtpConfig',
} as const;

export interface SMTPConfigResponse {
  user: string;
  pass: string;
  host: string;
  port: number;
  from: string;
  useSSL: boolean;
  object: EntityTypeSMTPCONFIG;
}

export type CreateSMTPConfigResponse = SMTPConfigResponse;

export interface UpsertSMTPConfigRequest {
  /** Specifies the user name */
  user?: string;
  /** Specifies the password */
  pass?: string;
  /** Specifies the host */
  host?: string;
  /** Specifies the from */
  from?: string;
  /** Specifies the port */
  port?: number;
  /** Specifies the use SSL */
  useSSL?: boolean;
}

export type GetSMTPConfigResponse = SMTPConfigResponse;

export interface DeleteSMTPConfigResponse {
  deleted: boolean;
  object: EntityTypeSMTPCONFIG;
}

export type EmailTypeResponse = typeof EmailTypeResponse[keyof typeof EmailTypeResponse];


export const EmailTypeResponse = {
  emailVerification: 'emailVerification',
  passwordReset: 'passwordReset',
} as const;

export type EntityTypeEMAILSAMPLE = typeof EntityTypeEMAILSAMPLE[keyof typeof EntityTypeEMAILSAMPLE];


export const EntityTypeEMAILSAMPLE = {
  emailSample: 'emailSample',
} as const;

export interface EmailSampleResponse {
  id: string;
  object: EntityTypeEMAILSAMPLE;
  createdAt: number;
  name: string;
  subject: string;
  body: string;
  type: EmailTypeResponse;
}

export type CreateEmailSampleResponse = EmailSampleResponse;

export type EmailTypeRequest = typeof EmailTypeRequest[keyof typeof EmailTypeRequest];


export const EmailTypeRequest = {
  emailVerification: 'emailVerification',
  passwordReset: 'passwordReset',
} as const;

export interface CreateEmailSampleRequest {
  /** Specifies the name */
  name: string;
  /** Specifies the subject */
  subject: string;
  /** Specifies the body */
  body: string;
  /** Specifies the type */
  type: EmailTypeRequest;
}

export type GetEmailSampleResponse = EmailSampleResponse;

export interface BaseEntityListResponseEmailSampleResponse {
  object: ResponseTypeLIST;
  url: string;
  data: EmailSampleResponse[];
  start: number;
  end: number;
  total: number;
}

export type EmailSampleListResponse = BaseEntityListResponseEmailSampleResponse;

export interface EmailSampleDeleteResponse {
  deleted: boolean;
  id: string;
  object: EntityTypeEMAILSAMPLE;
}

export type UpdateEmailSampleResponse = EmailSampleResponse;

export interface UpdateEmailSampleRequest {
  /** Specifies the name */
  name?: string;
  /** Specifies the subject */
  subject?: string;
  /** Specifies the body */
  body?: string;
  /** Specifies the type */
  type?: EmailTypeRequest;
}

export interface EcosystemMetadata {[key: string]: string | number}

export interface EcosystemConfigurationResponse {
  /** Subdomain of the ecosystem. */
  customDomain: string;
  /** Primary color of the ecosystem. */
  primaryColor: string;
  /** Primary color foreground of the ecosystem. */
  primaryColorForeground: string;
  /** Radius of the ecosystem. */
  radius: string;
  /** Logo URL of the ecosystem. */
  logoUrl: string;
  /** Whitelisted frontend domains of the ecosystem. */
  ecosystemWalletDomains: string[];
  /** Terms of service URL */
  termsOfServiceUrl?: string;
  /** Privacy policy URL */
  privacyPolicyUrl?: string;
  /** Favicon URL */
  faviconUrl?: string;
  /** Examples of the ecosystem. */
  dashboardExamples?: EcosystemMetadata[];
  /** SDKs of the ecosystem. */
  dashboardSDKs?: EcosystemMetadata[];
  /** Support email of the ecosystem. */
  supportEmail?: string;
  /** Documentation URL of the ecosystem. */
  documentationUrl?: string;
}

export interface CreateEcosystemConfigurationRequest {
  /** Custom domain of the ecosystem. */
  customDomain: string;
  /** Primary color of the ecosystem. */
  primaryColor: string;
  /** Primary color foreground of the ecosystem. */
  primaryColorForeground: string;
  /** Radius of the ecosystem. */
  radius: string;
  /** Logo URL of the ecosystem. */
  logoUrl: string;
  /** URLs where the ecosystem wallet is hosted. */
  ecosystemWalletDomains?: string[];
  /** Terms of service URL */
  termsOfServiceUrl?: string;
  /** Privacy policy URL */
  privacyPolicyUrl?: string;
  /** Favicon URL */
  faviconUrl?: string;
  /** Examples of the ecosystem. */
  dashboardExamples?: EcosystemMetadata[];
  /** SDKs of the ecosystem. */
  dashboardSDKs?: EcosystemMetadata[];
  /** Support email of the ecosystem. */
  supportEmail?: string;
  /** Documentation URL of the ecosystem. */
  documentationUrl?: string;
}

export interface MyEcosystemResponse {
  publishableKey: string;
  name: string;
  configuration?: EcosystemConfigurationResponse;
}

export type ApiKeyType = typeof ApiKeyType[keyof typeof ApiKeyType];


export const ApiKeyType = {
  pk: 'pk',
  sk: 'sk',
  pk_shield: 'pk_shield',
  sk_shield: 'sk_shield',
  pk_wallet: 'pk_wallet',
} as const;

export interface CreateProjectApiKeyRequest {
  /** The type of the API key. */
  type: ApiKeyType;
}

export interface UpdateProjectApiKeyRequest {
  /** The type of the API key. */
  type: ApiKeyType;
  /** The API key to update. */
  uuid: string;
  /** Whether key to use to sign webhooks. */
  use_for_webhooks?: boolean;
}

export interface AuthorizedOriginsResponse {
  origins: string[];
}

export interface UpdateAuthorizedOriginsRequest {
  origins: string[];
}

export type AuthorizedNetworksResponseAuthorizedNetworksItem = {
  network: string;
  name: string;
};

export interface AuthorizedNetworksResponse {
  authorizedNetworks: AuthorizedNetworksResponseAuthorizedNetworksItem[];
}

export interface AuthorizedNetwork {
  name: string;
  network: string;
}

export interface UpdateAuthorizedNetworksRequest {
  authorizedNetworks: AuthorizedNetwork[];
}

export type AuthorizedAppsResponseAuthorizedAppsItem = {
  appUrlScheme?: string;
  appIdentifier: string;
  name: string;
};

export interface AuthorizedAppsResponse {
  authorizedApps: AuthorizedAppsResponseAuthorizedAppsItem[];
}

export interface AuthorizedApp {
  name: string;
  appIdentifier: string;
  appUrlScheme?: string;
}

export interface UpdateAuthorizedAppsRequest {
  authorizedApps: AuthorizedApp[];
}

export type AuthProviderResponse = typeof AuthProviderResponse[keyof typeof AuthProviderResponse];


export const AuthProviderResponse = {
  email: 'email',
  wallet: 'wallet',
  google: 'google',
  apple: 'apple',
  twitter: 'twitter',
  discord: 'discord',
  epic_games: 'epic_games',
  facebook: 'facebook',
  accelbyte: 'accelbyte',
  firebase: 'firebase',
  lootlocker: 'lootlocker',
  playfab: 'playfab',
  supabase: 'supabase',
  custom: 'custom',
  oidc: 'oidc',
} as const;

export interface LinkedAccountResponse {
  provider: AuthProviderResponse;
  email?: string;
  externalUserId?: string;
  connectorType?: string;
  walletClientType?: string;
  disabled: boolean;
  verified?: boolean;
  updatedAt?: number;
  address?: string;
  metadata?: PlayerMetadata;
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickPlayerResponseId {
  id: string;
}

export interface AuthPlayerResponse {
  player?: PlayerResponse | PickPlayerResponseId;
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  linkedAccounts: LinkedAccountResponse[];
}

export interface AuthResponse {
  /** Player's identifier. */
  player: AuthPlayerResponse;
  /** JWT access token. */
  token: string;
  /** Refresh token. */
  refreshToken: string;
}

export interface RefreshTokenRequest {
  /** Specifies the session refresh token. */
  refreshToken: string;
  /** Specifies whether to force refresh the session. */
  forceRefresh?: boolean;
}

export interface LogoutRequest {
  /** Specifies the refresh token. */
  refreshToken: string;
}

export interface SIWEInitResponse {
  /** The address of the player. */
  address: string;
  nonce: string;
  expiresAt: number;
}

export interface SIWERequest {
  /** The address of the user. */
  address: string;
}

export interface SIWEAuthenticateRequest {
  /** Signature of the EIP-712 message with the user's wallet. */
  signature: string;
  /** The EIP-712 message to sign. */
  message: string;
  /** The wallet client of the user */
  walletClientType: string;
  /** The connector type of the user */
  connectorType: string;
}

export type Actions = typeof Actions[keyof typeof Actions];


export const Actions = {
  verify_email: 'verify_email',
} as const;

export interface ActionRequiredResponse {
  action: Actions;
}

export interface SignupRequest {
  /** The email address of the player. */
  email: string;
  /** The password of the player. */
  password: string;
  /** The name of the player. */
  name?: string;
  /** The description of the player. */
  description?: string;
}

export interface LoginRequest {
  /** The email address of the user. */
  email: string;
  /** The password of the user. */
  password: string;
}

/**
 * The code verifier.
 */
export type CodeChallengeMethod = typeof CodeChallengeMethod[keyof typeof CodeChallengeMethod];


export const CodeChallengeMethod = {
  plain: 'plain',
  S256: 'S256',
} as const;

export interface CodeChallenge {
  /** The code challenge. */
  codeChallenge: string;
  /** The code verifier. */
  method: CodeChallengeMethod;
}

export interface RequestVerifyEmailRequest {
  /** The email address of the user. */
  email: string;
  /** The URL sent to the user by email to reset the password. At the end of the URL, we will add the token in the format `?token=token`. */
  redirectUrl: string;
  /** The Code Challenge if you want to use PKCE. */
  challenge?: CodeChallenge;
}

export interface CodeChallengeVerify {
  /** The code verifier. */
  codeVerifier: string;
}

export interface VerifyEmailRequest {
  /** The email address of the user. */
  email: string;
  /** Unique value to identify the request. Obtained from the email. */
  token: string;
  /** The Code Challenge to verify the PKCE if you used it in the request. */
  challenge?: CodeChallengeVerify;
}

export interface RequestResetPasswordRequest {
  /** The email address of the user. */
  email: string;
  /** The URL sent to the user by email to reset the password. At the end of the URL, we will add the token in the format `?token=token`. */
  redirectUrl: string;
  /** The Code Challenge if you want to use PKCE. */
  challenge?: CodeChallenge;
}

export interface ResetPasswordRequest {
  /** The email address of the user. */
  email: string;
  /** The new password of the user. */
  password: string;
  /** Unique value to identify the request. It's used to mitigate CSRF attacks. */
  state?: string;
  /** The Code Challenge to verify the PKCE if you used it in the request. */
  challenge?: CodeChallengeVerify;
}

export interface UnlinkEmailRequest {
  /** The email address of the user. */
  email: string;
}

export interface LoginOIDCRequest {
  /** The identity token of the user. */
  identityToken: string;
}

export interface OAuthResponse {
  url: string;
  key: string;
}

/**
 * Enum of the supporting OAuth providers.
 */
export type OAuthProvider = typeof OAuthProvider[keyof typeof OAuthProvider];


export const OAuthProvider = {
  google: 'google',
  twitter: 'twitter',
  facebook: 'facebook',
  discord: 'discord',
  epic_games: 'epic_games',
  line: 'line',
  apple: 'apple',
} as const;

/**
 * An object of query params
 */
export type OAuthInitRequestOptionsQueryParams = {[key: string]: string};

export type OAuthInitRequestOptions = {
  /** A URL to custom handle the provider callback */
  callbackTo?: string;
  /** An object of query params */
  queryParams?: OAuthInitRequestOptionsQueryParams;
  /** A URL to send the user to after they are confirmed. */
  redirectTo?: string;
};

export interface OAuthInitRequest {
  options?: OAuthInitRequestOptions;
  /** Use Pooling for the OAuth flow

This option is for the flow that requires the user can't be redirected from the authorization page to the application.
The client should poll the server to check if the user has authorized the application. */
  usePooling?: boolean;
  /** One of the providers supported by Openfort */
  provider: OAuthProvider;
}

export interface ThirdPartyLinkRequest {
  provider: ThirdPartyOAuthProvider;
  token: string;
  tokenType: string;
}

export interface LoginWithIdTokenRequest {
  /** OAuth provider */
  provider: OAuthProvider;
  /** Token to be verified */
  token: string;
}

/**
 * Enum of the supporting OAuth providers.
 */
export type TokenType = typeof TokenType[keyof typeof TokenType];


export const TokenType = {
  idToken: 'idToken',
  customToken: 'customToken',
} as const;

export interface ThirdPartyOAuthRequest {
  /** OAuth provider */
  provider: ThirdPartyOAuthProvider;
  /** Token to be verified */
  token: string;
  tokenType?: TokenType;
}

export const AuthenticateOAuthRequestProvider = {...OAuthProvider,...ThirdPartyOAuthProvider,} as const
export interface AuthenticateOAuthRequest {
  /** OAuth provider */
  provider: typeof AuthenticateOAuthRequestProvider[keyof typeof AuthenticateOAuthRequestProvider];
  /** Token to be verified */
  token: string;
  /** Type of the token. */
  tokenType: TokenType;
  /** Specifies the fields to expand in the response. */
  expand?: PlayerResponseExpandable[];
}

/**
 * The request to verify access token
 */
export interface UnlinkOAuthRequest {
  /** The provider type being linked */
  provider: OAuthProvider;
}

export type BasicAuthProviderEMAIL = typeof BasicAuthProviderEMAIL[keyof typeof BasicAuthProviderEMAIL];


export const BasicAuthProviderEMAIL = {
  email: 'email',
} as const;

/**
 * Enum of the supporting Basic Auth providers.
 */
export type BasicAuthProvider = typeof BasicAuthProvider[keyof typeof BasicAuthProvider];


export const BasicAuthProvider = {
  email: 'email',
  wallet: 'wallet',
  guest: 'guest',
  web3: 'web3',
  phone: 'phone',
} as const;

/**
 * Enum of the supporting Auth providers.
 */
export const AuthProvider = {...OAuthProvider,...ThirdPartyOAuthProvider,...BasicAuthProvider,} as const
export type AuthProvider = typeof AuthProvider[keyof typeof AuthProvider];

/**
 * Password requirements configuration
 */
export type EmailAuthConfigPasswordRequirements = {
  /** Require at least one special character (default: false) */
  requireSpecialChar?: boolean;
  /** Require at least one number (default: false) */
  requireNumber?: boolean;
  /** Require at least one lowercase letter (default: false) */
  requireLowercase?: boolean;
  /** Require at least one uppercase letter (default: false) */
  requireUppercase?: boolean;
  /** Minimum password length (default: 6) */
  minLength: number;
};

/**
 * Email auth configuration
 */
export interface EmailAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderEMAIL;
  /** Allow unverified emails: Users will be able to sign in with unverified emails */
  allowUnverified: boolean;
  /** Length of the OTP code (default: 6) */
  otpLength: number;
  /** Password requirements configuration */
  passwordRequirements: EmailAuthConfigPasswordRequirements;
}

export type BasicAuthProviderGUEST = typeof BasicAuthProviderGUEST[keyof typeof BasicAuthProviderGUEST];


export const BasicAuthProviderGUEST = {
  guest: 'guest',
} as const;

export interface GuestAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderGUEST;
}

export type BasicAuthProviderWEB3 = typeof BasicAuthProviderWEB3[keyof typeof BasicAuthProviderWEB3];


export const BasicAuthProviderWEB3 = {
  web3: 'web3',
} as const;

export interface Web3AuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderWEB3;
}

export type BasicAuthProviderPHONE = typeof BasicAuthProviderPHONE[keyof typeof BasicAuthProviderPHONE];


export const BasicAuthProviderPHONE = {
  phone: 'phone',
} as const;

export type SmsProviderTWILIO = typeof SmsProviderTWILIO[keyof typeof SmsProviderTWILIO];


export const SmsProviderTWILIO = {
  twilio: 'twilio',
} as const;

/**
 * Twilio SMS provider configuration
 */
export interface TwilioSmsProviderConfig {
  provider: SmsProviderTWILIO;
  /** Twilio Account SID */
  accountSid: string;
  /** Twilio Auth Token */
  authToken: string;
  /** Twilio phone number (from) */
  phoneNumber: string;
}

export type SmsProviderMESSAGEBIRD = typeof SmsProviderMESSAGEBIRD[keyof typeof SmsProviderMESSAGEBIRD];


export const SmsProviderMESSAGEBIRD = {
  messagebird: 'messagebird',
} as const;

/**
 * MessageBird SMS provider configuration
 */
export interface MessageBirdSmsProviderConfig {
  provider: SmsProviderMESSAGEBIRD;
  /** MessageBird Access Key */
  accessKey: string;
  /** Sender name or number */
  originator: string;
}

export type SmsProviderTXTLOCAL = typeof SmsProviderTXTLOCAL[keyof typeof SmsProviderTXTLOCAL];


export const SmsProviderTXTLOCAL = {
  txtlocal: 'txtlocal',
} as const;

/**
 * TxtLocal SMS provider configuration
 */
export interface TxtLocalSmsProviderConfig {
  provider: SmsProviderTXTLOCAL;
  /** TxtLocal API Key */
  apiKey: string;
  /** Sender name */
  sender: string;
}

export type SmsProviderVONAGE = typeof SmsProviderVONAGE[keyof typeof SmsProviderVONAGE];


export const SmsProviderVONAGE = {
  vonage: 'vonage',
} as const;

/**
 * Vonage SMS provider configuration
 */
export interface VonageSmsProviderConfig {
  provider: SmsProviderVONAGE;
  /** Vonage API Key */
  apiKey: string;
  /** Vonage API Secret */
  apiSecret: string;
  /** Sender ID or phone number */
  from: string;
}

export type SmsProviderSMSAPI = typeof SmsProviderSMSAPI[keyof typeof SmsProviderSMSAPI];


export const SmsProviderSMSAPI = {
  sms_api: 'sms_api',
} as const;

/**
 * SMS API provider configuration
 */
export interface SmsApiProviderConfig {
  provider: SmsProviderSMSAPI;
  /** Sender name */
  from: string;
  /** SMSAPI OAuth token */
  token: string;
}

/**
 * Phone auth configuration
 */
export interface PhoneAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderPHONE;
  /** SMS provider configuration */
  smsProviderConfig: TwilioSmsProviderConfig | MessageBirdSmsProviderConfig | TxtLocalSmsProviderConfig | VonageSmsProviderConfig | SmsApiProviderConfig;
  /** SMS message template. Use {{ .Code }} to format the OTP code (default: "Your code is {{ .Code }}") */
  smsTemplate: string;
}

export type ThirdPartyOAuthProviderSUPABASE = typeof ThirdPartyOAuthProviderSUPABASE[keyof typeof ThirdPartyOAuthProviderSUPABASE];


export const ThirdPartyOAuthProviderSUPABASE = {
  supabase: 'supabase',
} as const;

/**
 * Supabase oauth configuration
 */
export interface SupabaseAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderSUPABASE;
  /** The unique Supabase URL which is supplied when you create a new project in your project dashboard. */
  url: string;
  /** The unique Supabase Key which is supplied when you create a new project in your project dashboard. */
  key: string;
}

export type ThirdPartyOAuthProviderOIDC = typeof ThirdPartyOAuthProviderOIDC[keyof typeof ThirdPartyOAuthProviderOIDC];


export const ThirdPartyOAuthProviderOIDC = {
  oidc: 'oidc',
} as const;

export interface OIDCAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderOIDC;
  /** PEM encoded public key to verify the JWT token */
  publicVerificationKey?: string;
  /** Audience of the JWT token */
  aud: string;
  /** JWKS URL to fetch the public key */
  jwksUrl?: string;
}

export type ThirdPartyOAuthProviderACCELBYTE = typeof ThirdPartyOAuthProviderACCELBYTE[keyof typeof ThirdPartyOAuthProviderACCELBYTE];


export const ThirdPartyOAuthProviderACCELBYTE = {
  accelbyte: 'accelbyte',
} as const;

/**
 * Accelbyte oauth configuration
 */
export interface AccelbyteOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderACCELBYTE;
  /** Base URI of your accelbyte gaming service environment. E.g. https://mygame.dev.gamingservices.accelbyte.io/ */
  baseUrl: string;
  /** Client ID of your accelbyte gaming service environment. */
  clientId: string;
  /** Secret of your confidential IAM client. */
  clientSecret: string;
}

export type OAuthProviderGOOGLE = typeof OAuthProviderGOOGLE[keyof typeof OAuthProviderGOOGLE];


export const OAuthProviderGOOGLE = {
  google: 'google',
} as const;

/**
 * Google oauth configuration
 */
export interface GoogleOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderGOOGLE;
  /** Google API client ID. */
  clientId: string;
  /** Google API client secret. */
  clientSecret?: string;
}

export type OAuthProviderTWITTER = typeof OAuthProviderTWITTER[keyof typeof OAuthProviderTWITTER];


export const OAuthProviderTWITTER = {
  twitter: 'twitter',
} as const;

/**
 * Twitter oauth configuration
 */
export interface TwitterOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderTWITTER;
  /** Twitter API consumer key. */
  clientId: string;
  /** Twitter API consumer secret. */
  clientSecret: string;
}

export type OAuthProviderFACEBOOK = typeof OAuthProviderFACEBOOK[keyof typeof OAuthProviderFACEBOOK];


export const OAuthProviderFACEBOOK = {
  facebook: 'facebook',
} as const;

export interface FacebookOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderFACEBOOK;
  /** Facebook API client ID. */
  clientId: string;
  /** Facebook API client secret. */
  clientSecret: string;
}

export type OAuthProviderAPPLE = typeof OAuthProviderAPPLE[keyof typeof OAuthProviderAPPLE];


export const OAuthProviderAPPLE = {
  apple: 'apple',
} as const;

export interface AppleOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderAPPLE;
  /** Apple API client ID (Service ID). */
  clientId: string;
  /** Pre-generated client secret JWT */
  clientSecret?: string;
}

export type OAuthProviderLINE = typeof OAuthProviderLINE[keyof typeof OAuthProviderLINE];


export const OAuthProviderLINE = {
  line: 'line',
} as const;

export interface LineOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderLINE;
  /** Line Channel ID. */
  channelId: string;
  /** Line Channel secret. */
  channelSecret: string;
}

export type OAuthProviderDISCORD = typeof OAuthProviderDISCORD[keyof typeof OAuthProviderDISCORD];


export const OAuthProviderDISCORD = {
  discord: 'discord',
} as const;

export interface DiscordOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderDISCORD;
  /** Discord API client ID. */
  clientId: string;
  /** Discord API client secret. */
  clientSecret: string;
}

export type OAuthProviderEPICGAMES = typeof OAuthProviderEPICGAMES[keyof typeof OAuthProviderEPICGAMES];


export const OAuthProviderEPICGAMES = {
  epic_games: 'epic_games',
} as const;

export interface EpicGamesOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderEPICGAMES;
  /** Epic Games API client ID. */
  clientId: string;
  /** Epic Games API client secret. */
  clientSecret: string;
}

export type ThirdPartyOAuthProviderPLAYFAB = typeof ThirdPartyOAuthProviderPLAYFAB[keyof typeof ThirdPartyOAuthProviderPLAYFAB];


export const ThirdPartyOAuthProviderPLAYFAB = {
  playfab: 'playfab',
} as const;

/**
 * PlayFab oauth configuration
 */
export interface PlayFabOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderPLAYFAB;
  /** Title ID of your Play Fab gaming service environment. */
  titleId: string;
}

export type ThirdPartyOAuthProviderFIREBASE = typeof ThirdPartyOAuthProviderFIREBASE[keyof typeof ThirdPartyOAuthProviderFIREBASE];


export const ThirdPartyOAuthProviderFIREBASE = {
  firebase: 'firebase',
} as const;

/**
 * Firebase configuration
 */
export interface FirebaseOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderFIREBASE;
  /** Project ID of your Firebase service environment. */
  projectId: string;
}

export type ThirdPartyOAuthProviderCUSTOM = typeof ThirdPartyOAuthProviderCUSTOM[keyof typeof ThirdPartyOAuthProviderCUSTOM];


export const ThirdPartyOAuthProviderCUSTOM = {
  custom: 'custom',
} as const;

export interface CustomAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderCUSTOM;
  /** Headers to send with the request */
  headers?: string;
  /** URL to send the request to to verify the payload */
  authenticationUrl: string;
}

export type ThirdPartyOAuthProviderLOOTLOCKER = typeof ThirdPartyOAuthProviderLOOTLOCKER[keyof typeof ThirdPartyOAuthProviderLOOTLOCKER];


export const ThirdPartyOAuthProviderLOOTLOCKER = {
  lootlocker: 'lootlocker',
} as const;

/**
 * LootLocker oauth configuration
 */
export interface LootLockerOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderLOOTLOCKER;
}

export type ThirdPartyOAuthProviderBETTERAUTH = typeof ThirdPartyOAuthProviderBETTERAUTH[keyof typeof ThirdPartyOAuthProviderBETTERAUTH];


export const ThirdPartyOAuthProviderBETTERAUTH = {
  'better-auth': 'better-auth',
} as const;

/**
 * Better Auth configuration
 */
export interface BetterAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderBETTERAUTH;
  /** Base URL of the Better Auth instance. E.g. https://your-app.com/api/auth */
  baseUrl: string;
}

export type AuthConfig = EmailAuthConfig | GuestAuthConfig | Web3AuthConfig | PhoneAuthConfig | SupabaseAuthConfig | OIDCAuthConfig | AccelbyteOAuthConfig | GoogleOAuthConfig | TwitterOAuthConfig | FacebookOAuthConfig | AppleOAuthConfig | LineOAuthConfig | DiscordOAuthConfig | EpicGamesOAuthConfig | PlayFabOAuthConfig | FirebaseOAuthConfig | CustomAuthConfig | LootLockerOAuthConfig | BetterAuthConfig;

/**
 * Response for the OAuth config list method.
 */
export interface OAuthConfigListResponse {
  /** List of the OAuth providers configurations */
  data: AuthConfig[];
}

export interface GrantOAuthResponse {
  authorizationCode?: string;
  accessToken?: string;
  refreshToken?: string;
  playerId?: string;
}

export interface GrantCallbackRequest {
  code: string;
  state: string;
}

/**
 * OAuth provider specific configuration.
 */
export type OAuthConfigResponse = AuthConfig;

/**
 * Request for the configuration endpoints for the OAuth providers
 */
export type OAuthConfigRequest = AuthConfig;

export type AuthMigrationStatus = typeof AuthMigrationStatus[keyof typeof AuthMigrationStatus];


export const AuthMigrationStatus = {
  created: 'created',
  running: 'running',
  paused: 'paused',
  completed: 'completed',
  failed: 'failed',
  canceled: 'canceled',
} as const;

/**
 * Mapping strategy for the migration. This is used to transform the ids between the source and destination providers.
For the transformation, the order of the operations is:
1. Trim the prefix and suffix from the destination id.
2. Add the prefix and suffix to the destination id.
When a user is authenticated in the destination provider, the id is transformed using the mapping strategy to find if exists in the source provider.
If the id is not found, the user is created in the destination provider.
If the id is found, the user in the destination provider is linked to the source provider.
 */
export interface MappingStrategy {
  /** Prefix to trim from the destination id. */
  trimPrefix?: string;
  /** Suffix to trim from the destination id. */
  trimSuffix?: string;
  /** Prefix to add to the destination id. */
  addPrefix?: string;
  /** Suffix to add to the destination id. */
  addSuffix?: string;
}

/**
 * Auth Migration Response.
 */
export interface AuthMigrationResponse {
  /** Unique identifier for the migration. */
  id: string;
  /** The source provider for the migration. */
  sourceProvider: AuthProvider;
  /** The destination provider for the migration. */
  destinationProvider: AuthProvider;
  /** The status of the migration. */
  status: AuthMigrationStatus;
  /** The created date of the migration. */
  createdAt: string;
  /** If the migration is finished, this will be the date it was finished. */
  finishedAt?: string;
  /** The mapping strategy used for the migration.
If not provided, the direct mapping will be used. */
  mappingStrategy?: MappingStrategy;
}

/**
 * Request for migrating authentication from one provider to another
 */
export interface CreateMigrationRequest {
  /** The mapping strategy used for the migration.
If not provided, the direct mapping will be used. */
  mappingStrategy?: MappingStrategy;
  /** Destination provider */
  destinationProvider: AuthProvider;
  /** Source provider */
  sourceProvider: AuthProvider;
}

export interface AuthMigrationListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AuthMigrationResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 * Request for listing Migrations
 */
export interface ListMigrationsRequest {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Source provider */
  sourceProvider?: AuthProvider;
  /** Destination provider */
  destinationProvider?: AuthProvider;
  /** Status of the migration */
  status?: AuthMigrationStatus[];
}

/**
 * Request for update the status of a migration
 */
export interface UpdateMigrationRequest {
  /** The mapping strategy used for the migration.
If not provided, the direct mapping will be used. */
  mappingStrategy?: MappingStrategy;
  /** Status of the migration */
  status: AuthMigrationStatus;
}

export type AuthenticationType = typeof AuthenticationType[keyof typeof AuthenticationType];


export const AuthenticationType = {
  oauth: 'oauth',
  basic: 'basic',
  third_party: 'third_party',
} as const;

export interface AuthProviderWithTypeResponse {
  type: AuthenticationType;
  provider: AuthProvider;
}

export interface AuthProviderListResponse {
  data: AuthProviderWithTypeResponse[];
}

export interface ListConfigRequest {
  enabled?: boolean;
}

export interface AuthPlayerResponseWithRecoveryShare {
  player?: PlayerResponse | PickPlayerResponseId;
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  linkedAccounts: LinkedAccountResponse[];
  recoveryShare?: string;
}

export interface CreateAuthPlayerRequest {
  /** The third party user id. */
  thirdPartyUserId: string;
  /** The third party provider. */
  thirdPartyProvider: ThirdPartyOAuthProvider;
  /** Pre generate embedded account. */
  preGenerateEmbeddedAccount: boolean;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata. */
  metadata?: PlayerMetadata;
}

export interface AuthPlayerListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AuthPlayerResponse[];
  start: number;
  end: number;
  total: number;
}

export interface AuthPlayerListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the email address of the user. */
  email?: string;
  /** Specifies the external user ID. */
  externalUserId?: string;
}

export interface AuthSessionResponse {
  livemode: boolean;
  projectId: string;
  playerId: string;
  issuer: string;
  issuedAt: number;
  expiration: number;
  sessionId: string;
}

export interface JwtKey {
  kty: string;
  x: string;
  y: string;
  crv: string;
  kid: string;
  use: string;
  alg: string;
}

export interface JwtKeyResponse {
  keys: JwtKey[];
}

export interface AuthenticatedPlayerResponse {
  /** Player's identifier. */
  player: AuthPlayerResponse;
}

export interface AuthorizePlayerRequest {
  /** The authorization code received from the api to authorize the project to use the Ecosystem player. */
  authorizationCode: string;
}

export type GetTransactionIntentsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: TransactionIntentResponseExpandable[];
/**
 * The chain ID. Must be a [supported chain](/development/chains).
 */
chainId?: number;
/**
 * Filter by account ID or developer account (starts with acc_ or dac_ respectively).
 */
account?: string[];
/**
 * Filter by player ID (starts with pla_).
 */
player?: string[];
/**
 * Filter by successful (1) or failed (0) transaction intents.
 */
status?: number;
/**
 * Filter by policy ID (starts with pol_).
 */
policy?: string[];
};

export type GetTransactionIntentParams = {
/**
 * Specifies the expandable fields.
 */
expand?: TransactionIntentResponseExpandable[];
};

export type ListSubscriptionLogsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the topic of the subscription logs
 */
topic?: APITopic;
/**
 * Specifies the status of the subscription logs
 */
status?: Status;
/**
 * Specifies the object ID of the object related to triggered notification
 */
object?: string;
/**
 * Specifies the subscription ID
 */
subscription?: string;
/**
 * Specifies the trigger ID
 */
trigger?: string;
/**
 * Specifies the request ID
 */
requestID?: string;
};

export type TestTrigger200 = {
  sent: boolean;
};

export type GetDeveloperAccountsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: DeveloperAccountResponseExpandable[];
/**
 * Specifies whether to include deleted dev accounts.
 */
deleted?: boolean;
};

export type GetDeveloperAccountParams = {
expand?: DeveloperAccountResponseExpandable[];
};

export type GetVerificationPayloadParams = {
/**
 * Specifies the address
 */
address: string;
};

export type GetPlayerSessionsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * The player ID (starts with pla_)
 */
player: string;
/**
 * Specifies the fields to expand in the response.
 */
expand?: SessionResponseExpandable[];
};

export type GetSessionParams = {
/**
 * Specifies the fields to expand.
 */
expand?: SessionResponseExpandable[];
};

export type GetPolicyRulesParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: GetPolicyRulesExpandItem[];
/**
 * Specifies the unique policy ID (starts with pol_).
 */
policy: string;
};

export type GetPolicyRulesExpandItem = typeof GetPolicyRulesExpandItem[keyof typeof GetPolicyRulesExpandItem];


export const GetPolicyRulesExpandItem = {
  contract: 'contract',
} as const;

export type GetPoliciesParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: PolicyResponseExpandable[];
/**
 * Specifies the name of the policy.
 */
name?: string;
/**
 * Specifies whether to include deleted policies.
 */
deleted?: boolean;
/**
 * The chain ID of the policy.
 */
chainId?: number;
/**
 * Specifies whether to include enabled policies.
 */
enabled?: boolean;
};

export type GetPolicyParams = {
/**
 * Specifies the fields to expand.
 */
expand?: PolicyResponseExpandable[];
};

export type GetPolicyTotalGasUsageParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
};

export type GetPolicyReportTransactionIntentsParams = {
/**
 * The start date of the period in unix timestamp.
 */
to: number;
/**
 * The end date of the period in unix timestamp.
 */
from: number;
};

export type GetPlayersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: PlayerResponseExpandable[];
/**
 * Filter by player name.
 */
name?: string;
};

export type GetPlayerParams = {
/**
 * Specifies the expandable fields.
 */
expand?: PlayerResponseExpandable[];
};

export type ListPaymastersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
};

export type GetProjectLogsParams = {
/**
 * .
 */
method?: string[];
/**
 * Specifies the unique project ID.
 */
id?: string;
};

export type ListForwarderContractsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
};

export type GetEventsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the name of the event
 */
name?: string;
/**
 * Specifies if display deleted events
 */
deleted?: boolean;
};

export type GetContractsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the name of the contract.
 */
name?: string;
/**
 * Specifies whether to include deleted contracts.
 */
deleted?: boolean;
/**
 * The chain ID of the contract.
 */
chainId?: number;
/**
 * Specifies the address of the contract.
 */
address?: string;
};

export type ReadContractParams = {
/**
 * The function name of the contract.
 */
functionName: string;
/**
 * The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs.
 */
functionArgs?: unknown[];
};

export type GetAccountsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * The chain ID. Must be a [supported chain](/development/chains).
 */
chainId?: number;
/**
 * Specifies the unique player ID (starts with pla_)
 */
player?: string;
/**
 * Specifies the address of the account
 */
address?: string;
/**
 * Specifies the fields to expand in the response.
 */
expand?: AccountResponseExpandable[];
};

export type GetAccountParams = {
expand?: AccountResponseExpandable[];
};

export type GetAuthUsersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Filter by user name.
 */
name?: string;
/**
 * Filter by external user ID (accountId from linked accounts).
 */
externalUserId?: string;
/**
 * Filter by user email.
 */
email?: string;
/**
 * Filter by user phone number.
 */
phoneNumber?: string;
/**
 * Filter by provider ID (e.g., "google", "apple", "siwe", "credential").
 */
authProviderId?: string;
/**
 * Filter by wallet client type (for SIWE accounts).
 */
walletClientType?: string;
};

export type ListPoliciesParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Filter by scope.
 */
scope?: ListPoliciesScope;
/**
 * Filter by enabled status.
 */
enabled?: boolean;
/**
 * Filter by account ID (for account-scoped policies).
 */
accountId?: string;
};

export type ListPoliciesScope = typeof ListPoliciesScope[keyof typeof ListPoliciesScope];


export const ListPoliciesScope = {
  project: 'project',
  account: 'account',
} as const;

export type ListBackendWalletsParams = {
/**
 * Number of wallets to return (default: 10, max: 100).
 */
limit?: number;
/**
 * Number of wallets to skip (for pagination).
 */
skip?: number;
/**
 * Filter by chain type.
 */
chainType?: ListBackendWalletsChainType;
/**
 * Filter by wallet address.
 */
address?: string;
/**
 * Filter by wallet name.
 */
name?: string;
/**
 * Filter by associated wallet ID (starts with `pla_`).
 */
wallet?: string;
};

export type ListBackendWalletsChainType = typeof ListBackendWalletsChainType[keyof typeof ListBackendWalletsChainType];


export const ListBackendWalletsChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export type GetAccountsV2Params = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * The chain ID. Must be a [supported chain](/development/chains).
 */
chainId?: number;
/**
 * Specifies the unique user ID (starts with pla_)
 */
user?: string;
/**
 * The chain type. Must be either "EVM" or "SVM".
 */
chainType?: GetAccountsV2ChainType;
/**
 * Specifies the type of account. Must be either "Smart Account" or "Externally Owned Account".
 */
accountType?: GetAccountsV2AccountType;
/**
 * Specifies the key custody of the account. Must be either "Developer" or "User".
 */
custody?: GetAccountsV2Custody;
/**
 * Specifies the account address
 */
address?: string;
};

export type GetAccountsV2ChainType = typeof GetAccountsV2ChainType[keyof typeof GetAccountsV2ChainType];


export const GetAccountsV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export type GetAccountsV2AccountType = typeof GetAccountsV2AccountType[keyof typeof GetAccountsV2AccountType];


export const GetAccountsV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

export type GetAccountsV2Custody = typeof GetAccountsV2Custody[keyof typeof GetAccountsV2Custody];


export const GetAccountsV2Custody = {
  Developer: 'Developer',
  User: 'User',
} as const;

export type GetSignerIdByAddressParams = {
address: string;
};

export type PoolOAuthParams = {
key: string;
};

export type DeprecatedCallbackOAuthParams = {
/**
 * Specifies the oauth code.
 */
code: string;
/**
 * Specifies the oauth state.
 */
state: string;
};

export type CallbackOAuthParams = {
/**
 * Specifies the oauth code.
 */
code: string;
/**
 * Specifies the oauth state.
 */
state: string;
};

export type ListParams = {
enabled?: boolean;
};

export type GetAuthPlayersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the email address of the user.
 */
email?: string;
/**
 * Specifies the external user ID.
 */
externalUserId?: string;
};

export type VerifyAuthTokenParams = {
/**
 * Specifies the auth token.
 */
token: string;
};

