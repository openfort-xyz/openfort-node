/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Openfort API
 * Complete Openfort API references and guides can be found at: https://www.openfort.io/docs
 * OpenAPI spec version: 1.0.0
 */
/**
 */
export type JsonRpcSuccessResponseAnyJsonrpc = typeof JsonRpcSuccessResponseAnyJsonrpc[keyof typeof JsonRpcSuccessResponseAnyJsonrpc];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JsonRpcSuccessResponseAnyJsonrpc = {
  '20': '2.0',
} as const;

/**
 * @nullable
 */
export type JsonRpcSuccessResponseAnyId = string | number | null;

/**
 * JSON-RPC 2.0 Success Response
 */
export interface JsonRpcSuccessResponseAny {
  /** */
  jsonrpc: JsonRpcSuccessResponseAnyJsonrpc;
  result: unknown;
  /** @nullable */
  id: JsonRpcSuccessResponseAnyId;
}

/**
 * JSON-RPC 2.0 Error Object
 */
export interface JsonRpcError {
  code: number;
  message: string;
  data?: unknown;
}

/**
 */
export type JsonRpcErrorResponseJsonrpc = typeof JsonRpcErrorResponseJsonrpc[keyof typeof JsonRpcErrorResponseJsonrpc];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JsonRpcErrorResponseJsonrpc = {
  '20': '2.0',
} as const;

/**
 * @nullable
 */
export type JsonRpcErrorResponseId = string | number | null;

/**
 * JSON-RPC 2.0 Error Response
 */
export interface JsonRpcErrorResponse {
  /** */
  jsonrpc: JsonRpcErrorResponseJsonrpc;
  error: JsonRpcError;
  /** @nullable */
  id: JsonRpcErrorResponseId;
}

/**
 * JSON-RPC 2.0 Response (either success or error)
 */
export type JsonRpcResponse = JsonRpcSuccessResponseAny | JsonRpcErrorResponse;

/**
 */
export type JsonRpcRequestJsonrpc = typeof JsonRpcRequestJsonrpc[keyof typeof JsonRpcRequestJsonrpc];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const JsonRpcRequestJsonrpc = {
  '20': '2.0',
} as const;

/**
 * @nullable
 */
export type JsonRpcRequestId = string | number | null;

/**
 * JSON-RPC 2.0 Request
 */
export interface JsonRpcRequest {
  /** */
  jsonrpc: JsonRpcRequestJsonrpc;
  method: string;
  params?: unknown;
  /** @nullable */
  id?: JsonRpcRequestId;
}

export interface CheckoutResponse {
  url: string;
}

export type Currency = typeof Currency[keyof typeof Currency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Currency = {
  usd: 'usd',
} as const;

export interface CheckoutRequest {
  /**
   * Amount in cents
   * @minimum 1
   */
  amount: number;
  currency: Currency;
  cancelUrl?: string;
  successUrl?: string;
}

export interface CheckoutSubscriptionRequest {
  plan: string;
  cancelUrl?: string;
  successUrl?: string;
}

export interface Money {
  /**
   * Amount in cents
   * @minimum 1
   */
  amount: number;
  currency: Currency;
}

export interface BalanceResponse {
  balance: Money;
  expenses: Money;
  payments: Money;
}

export type ResponseTypeLIST = typeof ResponseTypeLIST[keyof typeof ResponseTypeLIST];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResponseTypeLIST = {
  list: 'list',
} as const;

export interface EntityIdResponse {
  id: string;
}

export type SponsorSchemaPAYFORUSER = typeof SponsorSchemaPAYFORUSER[keyof typeof SponsorSchemaPAYFORUSER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SponsorSchemaPAYFORUSER = {
  pay_for_user: 'pay_for_user',
} as const;

export type SponsorSchema = typeof SponsorSchema[keyof typeof SponsorSchema];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SponsorSchema = {
  pay_for_user: 'pay_for_user',
  charge_custom_tokens: 'charge_custom_tokens',
  fixed_rate: 'fixed_rate',
} as const;

export interface PayForUserPolicyStrategy {
  sponsorSchema: SponsorSchemaPAYFORUSER;
  /** @nullable */
  depositor?: string | null;
}

export type SponsorSchemaCHARGECUSTOMTOKENS = typeof SponsorSchemaCHARGECUSTOMTOKENS[keyof typeof SponsorSchemaCHARGECUSTOMTOKENS];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SponsorSchemaCHARGECUSTOMTOKENS = {
  charge_custom_tokens: 'charge_custom_tokens',
} as const;

export interface ChargeCustomTokenPolicyStrategy {
  sponsorSchema: SponsorSchemaCHARGECUSTOMTOKENS;
  /** @nullable */
  depositor?: string | null;
  tokenContract: string;
  tokenContractAmount: string;
}

export type SponsorSchemaFIXEDRATE = typeof SponsorSchemaFIXEDRATE[keyof typeof SponsorSchemaFIXEDRATE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SponsorSchemaFIXEDRATE = {
  fixed_rate: 'fixed_rate',
} as const;

export interface FixedRateTokenPolicyStrategy {
  sponsorSchema: SponsorSchemaFIXEDRATE;
  /** @nullable */
  depositor?: string | null;
  tokenContract: string;
  tokenContractAmount: string;
}

export type PolicyStrategy = PayForUserPolicyStrategy | ChargeCustomTokenPolicyStrategy | FixedRateTokenPolicyStrategy;

export type EntityTypePOLICY = typeof EntityTypePOLICY[keyof typeof EntityTypePOLICY];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypePOLICY = {
  policy: 'policy',
} as const;

export interface Policy {
  id: string;
  object: EntityTypePOLICY;
  createdAt: number;
  /** @nullable */
  name: string | null;
  deleted: boolean;
  enabled: boolean;
  /** The chain ID. */
  chainId: number;
  paymaster?: EntityIdResponse;
  forwarderContract?: EntityIdResponse;
  strategy: PolicyStrategy;
  transactionIntents: EntityIdResponse[];
  policyRules: EntityIdResponse[];
}

export interface PlayerMetadata {[key: string]: string | number}

export type EntityTypePLAYER = typeof EntityTypePLAYER[keyof typeof EntityTypePLAYER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypePLAYER = {
  player: 'player',
} as const;

export interface Player {
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  name: string;
  description?: string;
  metadata?: PlayerMetadata;
  transactionIntents?: EntityIdResponse[];
  accounts?: EntityIdResponse[];
}

export type EntityTypeACCOUNT = typeof EntityTypeACCOUNT[keyof typeof EntityTypeACCOUNT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeACCOUNT = {
  account: 'account',
} as const;

export interface Account {
  id: string;
  object: EntityTypeACCOUNT;
  createdAt: number;
  address: string;
  ownerAddress: string;
  deployed: boolean;
  custodial: boolean;
  embeddedSigner: boolean;
  /** The chain ID. */
  chainId: number;
  accountType: string;
  pendingOwnerAddress?: string;
  transactionIntents?: EntityIdResponse[];
  player: EntityIdResponse;
}

export type EntityTypeDEVELOPERACCOUNT = typeof EntityTypeDEVELOPERACCOUNT[keyof typeof EntityTypeDEVELOPERACCOUNT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeDEVELOPERACCOUNT = {
  developerAccount: 'developerAccount',
} as const;

export interface DeveloperAccount {
  id: string;
  object: EntityTypeDEVELOPERACCOUNT;
  createdAt: number;
  address: string;
  custodial: boolean;
  name?: string;
  transactionIntents?: EntityIdResponse[];
}

export type TransactionAbstractionType = typeof TransactionAbstractionType[keyof typeof TransactionAbstractionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionAbstractionType = {
  accountAbstractionV6: 'accountAbstractionV6',
  accountAbstractionV8: 'accountAbstractionV8',
  accountAbstractionV9: 'accountAbstractionV9',
  zkSync: 'zkSync',
  standard: 'standard',
} as const;

export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionStatus = {
  none: 'none',
  new: 'new',
  sent: 'sent',
  dropped: 'dropped',
  indexed: 'indexed',
  confirmed: 'confirmed',
  reverted: 'reverted',
  notfound: 'notfound',
  replaced: 'replaced',
  expired: 'expired',
} as const;

/**
 * A transition represents a change in the status of a transaction intent.
 */
export interface Transition {
  fromStatus: TransactionStatus;
  toStatus: TransactionStatus;
  at: number;
}

export interface ZKSyncDetails {
  /** The transaction sender. */
  from: string;
  /** The transaction recipient or contract address. */
  to: string;
  /** A contract hashed method call with encoded args. */
  data?: string;
  /** Unique number identifying this transaction. */
  nonce: string;
  /** The gas limit for the transaction. */
  gas: string;
  /** Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to EIP-1559 Transactions. */
  maxFeePerGas: string;
  /** Max priority fee per gas (in wei). Only applies to EIP-1559 Transactions. */
  maxPriorityFeePerGas: string;
  /** Address of the paymaster account that will pay the fees. */
  paymaster?: string;
  /** Input data to the paymaster */
  paymasterInput?: string;
  /** Value in wei sent with this transaction. */
  value?: string;
}

export interface UserOperationV6 {
  /** The data to pass to the `sender` during the main execution call. */
  callData: string;
  /** The amount of gas to allocate the main execution call */
  callGasLimit: string;
  /** Account init code. Only for new accounts. */
  initCode?: string;
  /** Maximum fee per gas. */
  maxFeePerGas: string;
  /** Maximum priority fee per gas. */
  maxPriorityFeePerGas: string;
  /** Anti-replay parameter. */
  nonce: string;
  /** Paymaster address with calldata. */
  paymasterAndData?: string;
  /** Extra gas to pay the bundler. */
  preVerificationGas: string;
  /** The account making the operation. */
  sender: string;
  /** Data passed into the account to verify authorization. */
  signature: string;
  /** The amount of gas to allocate for the verification step. */
  verificationGasLimit: string;
}

export interface AccountAbstractionV6Details {
  userOperation: UserOperationV6;
  /** A User Operation hash. */
  userOperationHash: string;
}

export interface UserOperationV8 {
  /** The data to pass to the `sender` during the main execution call. */
  callData: string;
  /** The amount of gas to allocate the main execution call */
  callGasLimit: string;
  /** Account init code. Only for new accounts. */
  factory?: string;
  /** Factory data for account creation. */
  factoryData?: string;
  /** Maximum fee per gas. */
  maxFeePerGas: string;
  /** Maximum priority fee per gas. */
  maxPriorityFeePerGas: string;
  /** Anti-replay parameter. */
  nonce: string;
  /** Paymaster address. */
  paymaster?: string;
  /** Paymaster verification gas limit. */
  paymasterVerificationGasLimit?: string;
  /** Paymaster post-operation gas limit. */
  paymasterPostOpGasLimit?: string;
  /** Paymaster data. */
  paymasterData?: string;
  /** Extra gas to pay the bundler. */
  preVerificationGas: string;
  /** The account making the operation. */
  sender: string;
  /** Data passed into the account to verify authorization. */
  signature: string;
  /** The amount of gas to allocate for the verification step. */
  verificationGasLimit: string;
}

export interface AccountAbstractionV8Details {
  userOperation: UserOperationV8;
  /** A User Operation hash. */
  userOperationHash: string;
}

/**
 * V9 UserOperation extends V8 with paymasterSignature field.
paymasterSignature enables parallelizable Paymaster signing -
data can be passed to the Paymaster after the UserOperation is signed by the wallet.
 */
export interface UserOperationV9 {
  /** The data to pass to the `sender` during the main execution call. */
  callData: string;
  /** The amount of gas to allocate the main execution call */
  callGasLimit: string;
  /** Account init code. Only for new accounts. */
  factory?: string;
  /** Factory data for account creation. */
  factoryData?: string;
  /** Maximum fee per gas. */
  maxFeePerGas: string;
  /** Maximum priority fee per gas. */
  maxPriorityFeePerGas: string;
  /** Anti-replay parameter. */
  nonce: string;
  /** Paymaster address. */
  paymaster?: string;
  /** Paymaster verification gas limit. */
  paymasterVerificationGasLimit?: string;
  /** Paymaster post-operation gas limit. */
  paymasterPostOpGasLimit?: string;
  /** Paymaster data. */
  paymasterData?: string;
  /** Extra gas to pay the bundler. */
  preVerificationGas: string;
  /** The account making the operation. */
  sender: string;
  /** Data passed into the account to verify authorization. */
  signature: string;
  /** The amount of gas to allocate for the verification step. */
  verificationGasLimit: string;
  /** Paymaster signature - enables parallelizable signing.
This field does not affect the UserOperation hash, allowing
the sender and paymaster to sign in parallel. */
  paymasterSignature?: string;
}

/**
 * V9 details - extends V8 with paymasterSignature for parallelizable signing
 */
export interface AccountAbstractionV9Details {
  userOperation: UserOperationV9;
  /** A User Operation hash. */
  userOperationHash: string;
}

export interface StandardDetails {
  /** The transaction sender. */
  from: string;
  /** The transaction recipient or contract address. */
  to: string;
  /** A contract hashed method call with encoded args. */
  data?: string;
  /** Unique number identifying this transaction. */
  nonce: string;
  /** The gas limit for the transaction. */
  gas: string;
  /** Total fee per gas (in wei), inclusive of `maxPriorityFeePerGas`. Only applies to EIP-1559 Transactions. */
  maxFeePerGas: string;
  /** Max priority fee per gas (in wei). Only applies to EIP-1559 Transactions. */
  maxPriorityFeePerGas: string;
  /** Value in wei sent with this transaction. */
  value?: string;
}

export interface TransactionResponseLog {
  blockNumber: number;
  blockHash: string;
  transactionIndex: number;
  removed: boolean;
  address: string;
  data: string;
  topics: string[];
  transactionHash: string;
  logIndex: number;
  orphaned?: boolean;
}

export interface ResponseResponse {
  /** The unix timestamp in seconds when the transactionIntent was created. */
  createdAt: number;
  /** The block height (number) of the block including the transaction of this log. */
  blockNumber?: number;
  /** The transaction hash of the transaction of this log. */
  transactionHash?: string;
  /** The l1 gas used by the transaction of this log. */
  l1GasUsed?: string;
  /** The gas used by the transaction of this log. */
  gasUsed?: string;
  /** The gas fee by the transaction of this log. */
  gasFee?: string;
  /** The l1 gas fee by the transaction of this log. */
  l1GasFee?: string;
  /** The status of the transaction of this log. */
  status?: number;
  /** The logs of the transaction of this log. */
  logs?: TransactionResponseLog[];
  /** The address of the contract of this log. */
  to?: string;
  /** The error of the transaction of this log. */
  error?: unknown;
}

export interface Interaction {
  /** The address of the recipient of native tokens. Use *only* to transfer native tokens. If you provide one of a `pla_...`,  or `acc_...` it will be converted to the corresponding address. */
  to?: string;
  /** The value intended to be sent with the transaction. Should be a stringified number in WEI (i.e. factor 10^18).
* */
  value?: string;
  /** The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`. */
  contract?: string;
  /** The function name of the contract. Accepts a a function signature as well (e.g. mint(address)). */
  functionName?: string;
  /** The function arguments of the contract, in string format. If you provide one of a `pla_...`, `con_...` or `acc_...` it will be converted to the corresponding address. */
  functionArgs?: unknown[];
  /** Data to append to the end of the calldata. Useful for [adding a "domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f) */
  dataSuffix?: string;
  /** The encoded calldata of the contract. */
  data?: string;
}

export type NextActionType = typeof NextActionType[keyof typeof NextActionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NextActionType = {
  sign_with_wallet: 'sign_with_wallet',
} as const;

export interface NextActionPayload {
  /**
   * The userOperation.
   * @deprecated
   */
  userOp?: unknown;
  /**
   * The hashed userOperation.
   * @deprecated
   */
  userOpHash?: string;
  /**
   * The userOperation.
   * @deprecated
   */
  userOperation?: unknown;
  /**
   * The hashed userOperation.
   * @deprecated
   */
  userOperationHash?: string;
  /** chain-agnostic hash to sign. */
  signableHash?: string;
}

export interface NextActionResponse {
  type: NextActionType;
  payload: NextActionPayload;
}

export type EntityTypeTRANSACTIONINTENT = typeof EntityTypeTRANSACTIONINTENT[keyof typeof EntityTypeTRANSACTIONINTENT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeTRANSACTIONINTENT = {
  transactionIntent: 'transactionIntent',
} as const;

/**
 * Specific transaction details based on its type
 */
export type TransactionIntentResponseDetails = ZKSyncDetails | AccountAbstractionV6Details | AccountAbstractionV8Details | AccountAbstractionV9Details | StandardDetails;

/**
 * The policy ID (starts with pol_).
 */
export type TransactionIntentResponsePolicy = Policy | EntityIdResponse;

/**
 * The player ID (starts with pla_).
 */
export type TransactionIntentResponsePlayer = Player | EntityIdResponse;

/**
 * The account ID (starts with acc_).
 */
export type TransactionIntentResponseAccount = Account | EntityIdResponse | DeveloperAccount;

export interface TransactionIntentResponse {
  id: string;
  object: EntityTypeTRANSACTIONINTENT;
  createdAt: number;
  /** The unix timestamp in seconds when the transactionIntent was created. */
  updatedAt: number;
  /** The chain ID. */
  chainId: number;
  /** The transaction abstraction type */
  abstractionType: TransactionAbstractionType;
  /** Transition of statuses the transaction has gone through. */
  transitions?: Transition[];
  /** Specific transaction details based on its type */
  details?: TransactionIntentResponseDetails;
  /** @deprecated */
  userOperationHash?: string;
  /** @deprecated */
  userOperation?: unknown;
  response?: ResponseResponse;
  interactions?: Interaction[];
  nextAction?: NextActionResponse;
  /** The policy ID (starts with pol_). */
  policy?: TransactionIntentResponsePolicy;
  /** The player ID (starts with pla_). */
  player?: TransactionIntentResponsePlayer;
  /** The account ID (starts with acc_). */
  account: TransactionIntentResponseAccount;
}

export interface TransactionIntentListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: TransactionIntentResponse[];
  start: number;
  end: number;
  total: number;
}

export type ErrorTypeINVALIDREQUESTERROR = typeof ErrorTypeINVALIDREQUESTERROR[keyof typeof ErrorTypeINVALIDREQUESTERROR];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorTypeINVALIDREQUESTERROR = {
  invalid_request_error: 'invalid_request_error',
} as const;

export interface FieldErrors {[key: string]: {
  value?: unknown;
  message: string;
}}

export interface InvalidRequestError {
  type: ErrorTypeINVALIDREQUESTERROR;
  message: string;
  details?: FieldErrors;
}

export interface InvalidRequestErrorResponse {
  error: InvalidRequestError;
}

/**
 */
export type TransactionIntentResponseExpandable = typeof TransactionIntentResponseExpandable[keyof typeof TransactionIntentResponseExpandable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionIntentResponseExpandable = {
  policy: 'policy',
  player: 'player',
  account: 'account',
} as const;

export type PrismaSortOrder = typeof PrismaSortOrder[keyof typeof PrismaSortOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PrismaSortOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export interface TransactionIntentListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: TransactionIntentResponseExpandable[];
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Filter by account ID or developer account (starts with acc_ or dac_ respectively). */
  account?: string[];
  /** Filter by player ID (starts with pla_). */
  player?: string[];
  /** Filter by successful (1) or failed (0) transaction intents. */
  status?: number;
  /** Filter by policy ID (starts with pol_). */
  policy?: string[];
}

export interface CreateTransactionIntentRequest {
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** ID of the Player this TransactionIntent belongs to, if one exists (starts with `pla_`).

If you omit this parameter a new Player will be created. */
  player?: string;
  /** ID of the Account this TransactionIntent is executed with, if one exists (starts with `acc_` or `dac_`).

When providing a Player and ChainID, you can omit this parameter. */
  account?: string;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas. */
  policy?: string;
  /** Use this parameter to create a new Account for Player with the provided owner address.

If you omit this parameter and no Account exists for the Player, a custodial Account will be created. */
  externalOwnerAddress?: string;
  /** Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain. */
  optimistic?: boolean;
  /** Signed authorization for delegated accounts. This signature is used to authorize the user operation for AccountAbstractionV8.
The signature should be in the format "0x..." and will be parsed to extract r, s, and yParity values. */
  signedAuthorization?: string;
  interactions: Interaction[];
}

/**
 * return value from estimateTransactionIntentCost
 */
export interface EstimateTransactionIntentGasResult {
  /** estimated TX gas cost */
  estimatedTXGas: string;
  /** estimated TX gas cost in the chain native token (WEI) */
  estimatedTXGasFee: string;
  /** estimated TX gas cost in USD */
  estimatedTXGasFeeUSD: string;
  /** when using a policy, the estimated TX gas cost in the ERC-20 token defined in the strategy (WEI) */
  estimatedTXGasFeeToken?: string;
  /** gas price used for the estimation */
  gasPrice: string;
}

export interface SignatureRequest {
  /** signed userOperationHash by the owner or valid session key */
  signature: string;
  /** Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain. */
  optimistic?: boolean;
}

export type APITopic = typeof APITopic[keyof typeof APITopic];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APITopic = {
  transaction_intentbroadcast: 'transaction_intent.broadcast',
  transaction_intentsuccessful: 'transaction_intent.successful',
  transaction_intentcancelled: 'transaction_intent.cancelled',
  transaction_intentfailed: 'transaction_intent.failed',
  balanceproject: 'balance.project',
  balancecontract: 'balance.contract',
  balancedev_account: 'balance.dev_account',
  test: 'test',
} as const;

export type APITriggerType = typeof APITriggerType[keyof typeof APITriggerType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APITriggerType = {
  webhook: 'webhook',
  email: 'email',
} as const;

export type EntityTypeTRIGGER = typeof EntityTypeTRIGGER[keyof typeof EntityTypeTRIGGER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeTRIGGER = {
  trigger: 'trigger',
} as const;

export interface TriggerResponse {
  id: string;
  object: EntityTypeTRIGGER;
  createdAt: number;
  target: string;
  type: APITriggerType;
  subscription: string;
  updatedAt?: number;
}

export type EntityTypeSUBSCRIPTION = typeof EntityTypeSUBSCRIPTION[keyof typeof EntityTypeSUBSCRIPTION];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeSUBSCRIPTION = {
  subscription: 'subscription',
} as const;

export interface SubscriptionResponse {
  id: string;
  object: EntityTypeSUBSCRIPTION;
  createdAt: number;
  topic: APITopic;
  triggers: TriggerResponse[];
  updatedAt?: number;
}

export interface SubscriptionListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: SubscriptionResponse[];
  start: number;
  end: number;
  total: number;
}

export type Status = typeof Status[keyof typeof Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  success: 'success',
  failed: 'failed',
} as const;

export type EntityTypeLOG = typeof EntityTypeLOG[keyof typeof EntityTypeLOG];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeLOG = {
  log: 'log',
} as const;

export interface LogResponse {
  id: string;
  object: EntityTypeLOG;
  createdAt: number;
  topic: APITopic;
  status: Status;
  subscription: string;
  trigger: string;
  requestID: string;
}

export interface BaseEntityListResponseLogResponse {
  object: ResponseTypeLIST;
  url: string;
  data: LogResponse[];
  start: number;
  end: number;
  total: number;
}

export type SubscriptionLogsResponse = BaseEntityListResponseLogResponse;

export interface ListSubscriptionLogsRequest {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the topic of the subscription logs */
  topic?: APITopic;
  /** Specifies the status of the subscription logs */
  status?: Status;
  /** Specifies the object ID of the object related to triggered notification */
  object?: string;
  /** Specifies the subscription ID */
  subscription?: string;
  /** Specifies the trigger ID */
  trigger?: string;
  /** Specifies the request ID */
  requestID?: string;
}

export type GetSubscriptionResponse = SubscriptionResponse;

export type CreateSubscriptionResponse = SubscriptionResponse;

export interface CreateTriggerRequest {
  /** Specifies the target of the trigger */
  target: string;
  /** Specifies the type of the trigger */
  type: APITriggerType;
  /** Specifies the subscription ID */
  subscription?: string;
}

export interface CreateSubscriptionRequest {
  /** Specifies the topic of the subscription */
  topic: APITopic;
  /** Specifies the triggers of the subscription */
  triggers: CreateTriggerRequest[];
}

export interface SubscriptionDeleteResponse {
  id: string;
  object: EntityTypeSUBSCRIPTION;
  deleted: boolean;
}

export interface BaseEntityListResponseTriggerResponse {
  object: ResponseTypeLIST;
  url: string;
  data: TriggerResponse[];
  start: number;
  end: number;
  total: number;
}

export type TriggerListResponse = BaseEntityListResponseTriggerResponse;

export type GetTriggerResponse = TriggerResponse;

export type CreateTriggerResponse = TriggerResponse;

export interface TriggerDeleteResponse {
  id: string;
  object: EntityTypeTRIGGER;
  deleted: boolean;
}

/**
 * Specific transaction details based on its type
 */
export type TransactionIntentDetails = ZKSyncDetails | AccountAbstractionV6Details | AccountAbstractionV8Details | AccountAbstractionV9Details | StandardDetails;

export interface TransactionIntent {
  id: string;
  object: EntityTypeTRANSACTIONINTENT;
  createdAt: number;
  /** The unix timestamp in seconds when the transactionIntent was created. */
  updatedAt: number;
  /** The chain ID. */
  chainId: number;
  /** The transaction abstraction type */
  abstractionType: TransactionAbstractionType;
  /** Transition of statuses the transaction has gone through. */
  transitions?: Transition[];
  /** Specific transaction details based on its type */
  details?: TransactionIntentDetails;
  /** @deprecated */
  userOperationHash?: string;
  /** @deprecated */
  userOperation?: unknown;
  response?: ResponseResponse;
  interactions?: Interaction[];
  nextAction?: NextActionResponse;
  /** The policy ID (starts with pol_). */
  policy?: EntityIdResponse;
  /** The player ID (starts with pla_). */
  player?: EntityIdResponse;
  /** The account ID. */
  account: EntityIdResponse;
}

export type DeveloperAccountResponseTransactionIntentsItem = TransactionIntent | EntityIdResponse;

export interface DeveloperAccountResponse {
  id: string;
  object: EntityTypeDEVELOPERACCOUNT;
  createdAt: number;
  address: string;
  custodial: boolean;
  name?: string;
  transactionIntents?: DeveloperAccountResponseTransactionIntentsItem[];
}

export interface DeveloperAccountListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: DeveloperAccountResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 */
export type DeveloperAccountResponseExpandable = typeof DeveloperAccountResponseExpandable[keyof typeof DeveloperAccountResponseExpandable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeveloperAccountResponseExpandable = {
  transactionIntents: 'transactionIntents',
} as const;

export interface DeveloperAccountListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: DeveloperAccountResponseExpandable[];
  /** Specifies whether to include deleted dev accounts. */
  deleted?: boolean;
}

export interface CreateDeveloperAccountCreateRequest {
  /** The address of the wallet that has deposited funds in the paymaster. */
  address?: string;
  /** Signature to verify the account ownership. */
  signature?: string;
  /** The name of the account. */
  name?: string;
}

export type EntityTypeSIGNATURE = typeof EntityTypeSIGNATURE[keyof typeof EntityTypeSIGNATURE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeSIGNATURE = {
  signature: 'signature',
} as const;

export interface SignPayloadResponse {
  object: EntityTypeSIGNATURE;
  account: string;
  address: string;
  hash: string;
  signature: string;
}

export interface TypedDomainData {
  /** The chain ID. */
  chainId: number;
  /** The user readable name of signing domain, i.e. the name of the DApp or the protocol.. */
  name?: string;
  /** The current major version of the signing domain. Signatures from different versions are not compatible. */
  version?: string;
  /** The address of the contract that will verify the signature. The user-agent may do contract specific phishing prevention. */
  verifyingContract?: string;
  /** An disambiguating salt for the protocol. This can be used as a domain separator of last resort. */
  salt?: string;
}

export interface TypedDataField {
  name: string;
  type: string;
}

export type SignPayloadRequestTypes = {[key: string]: TypedDataField[]};

export type SignPayloadRequestValue = {[key: string]: unknown};

export interface SignPayloadRequest {
  /** Domain. Specific to the dApp. */
  domain: TypedDomainData;
  types: SignPayloadRequestTypes;
  primaryType: string;
  value: SignPayloadRequestValue;
  /** Hash to verify and that will be signed */
  hash?: string;
}

export interface UpdateDeveloperAccountCreateRequest {
  /** The name of the account. */
  name?: string;
}

export interface DeveloperAccountGetMessageResponse {
  message: string;
  address: string;
}

export interface DeveloperAccountDeleteResponse {
  id: string;
  object: EntityTypeDEVELOPERACCOUNT;
  deleted: boolean;
}

export type EntityTypeSESSION = typeof EntityTypeSESSION[keyof typeof EntityTypeSESSION];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeSESSION = {
  session: 'session',
} as const;

export type SessionResponseTransactionIntentsItem = TransactionIntent | EntityIdResponse;

export interface SessionResponse {
  id: string;
  object: EntityTypeSESSION;
  createdAt: number;
  updatedAt: number;
  isActive: boolean;
  address: string;
  validAfter: string;
  validUntil: string;
  /** The account ID. */
  account: EntityIdResponse;
  whitelist: string[];
  limit: number;
  nextAction?: NextActionResponse;
  transactionIntents?: SessionResponseTransactionIntentsItem[];
}

export interface SessionListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: SessionResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 * Contains list of the expandable fields for the session response
 */
export type SessionResponseExpandable = typeof SessionResponseExpandable[keyof typeof SessionResponseExpandable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionResponseExpandable = {
  transactionIntents: 'transactionIntents',
} as const;

export interface SessionListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** The player ID (starts with pla_) */
  player: string;
  /** Specifies the fields to expand in the response. */
  expand?: SessionResponseExpandable[];
}

export interface CreateSessionRequest {
  /** The address of the session key. */
  address: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** If no account exists for a given player, create one with this address. */
  externalOwnerAddress?: string;
  /**
   * Maximum number of times the session key can be used.
   * @minimum 1
   */
  limit?: number;
  /** Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain. */
  optimistic?: boolean;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas. */
  policy?: string;
  /** The unix timestamp in seconds when the session key becomes valid. */
  validAfter: number;
  /** The unix timestamp in seconds when the session key expires. */
  validUntil: number;
  /** The list of whitelisted addresses (contracts the session key can interact with). */
  whitelist?: string[];
  /** The player ID (starts with pla_). */
  player?: string;
  /** ID of the Account this TransactionIntent is executed with, if one exists (starts with `acc_` or `dac_`).

When providing a Player and ChainID, you can omit this parameter. */
  account?: string;
}

export interface RevokeSessionRequest {
  /** The address of the session key to revoke. */
  address: string;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas. */
  policy?: string;
  /** Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not. */
  optimistic?: boolean;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** The player ID (starts with pla_). */
  player?: string;
  /** ID of the Account this TransactionIntent is executed with, if one exists (starts with `acc_` or `dac_`).

When providing a Player and ChainID, you can omit this parameter. */
  account?: string;
}

export type PolicyRuleTypeCONTRACT = typeof PolicyRuleTypeCONTRACT[keyof typeof PolicyRuleTypeCONTRACT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRuleTypeCONTRACT = {
  contract_functions: 'contract_functions',
} as const;

export type PolicyRuleType = typeof PolicyRuleType[keyof typeof PolicyRuleType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRuleType = {
  contract_functions: 'contract_functions',
  account_functions: 'account_functions',
  rate_limit: 'rate_limit',
} as const;

export type EntityTypePOLICYRULE = typeof EntityTypePOLICYRULE[keyof typeof EntityTypePOLICYRULE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypePOLICYRULE = {
  policyRule: 'policyRule',
} as const;

export interface AbiType {
  name?: string;
  type?: string;
  indexed?: boolean;
  internalType?: unknown;
  components?: AbiType[];
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickJsonFragmentTypeExcludeKeyofJsonFragmentTypeComponents {
  name?: string;
  type?: string;
  indexed?: boolean;
  internalType?: unknown;
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickJsonFragmentExcludeKeyofJsonFragmentInputsOrOutputs {
  name?: string;
  type?: string;
  anonymous?: boolean;
  payable?: boolean;
  constant?: boolean;
  stateMutability?: string;
  gas?: string;
}

export interface Abi {
  name?: string;
  type?: string;
  anonymous?: boolean;
  payable?: boolean;
  constant?: boolean;
  stateMutability?: string;
  gas?: string;
  inputs?: AbiType[];
  outputs?: AbiType[];
}

export type EntityTypeCONTRACT = typeof EntityTypeCONTRACT[keyof typeof EntityTypeCONTRACT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeCONTRACT = {
  contract: 'contract',
} as const;

export interface ContractResponse {
  id: string;
  object: EntityTypeCONTRACT;
  createdAt: number;
  /** @nullable */
  name: string | null;
  /** The chain ID. */
  chainId: number;
  address: string;
  deleted: boolean;
  abi: Abi[];
  publicVerification: boolean;
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickContractResponseId {
  id: string;
}

export type ContractPolicyRuleResponseContract = ContractResponse | PickContractResponseId;

export interface ContractPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeCONTRACT;
  contract?: ContractPolicyRuleResponseContract;
  functionName?: string;
  wildcard: boolean;
}

export type PolicyRuleTypeACCOUNT = typeof PolicyRuleTypeACCOUNT[keyof typeof PolicyRuleTypeACCOUNT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRuleTypeACCOUNT = {
  account_functions: 'account_functions',
} as const;

export interface AccountPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeACCOUNT;
}

export type PolicyRateLimitGASPERTRANSACTION = typeof PolicyRateLimitGASPERTRANSACTION[keyof typeof PolicyRateLimitGASPERTRANSACTION];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRateLimitGASPERTRANSACTION = {
  gas_per_transaction: 'gas_per_transaction',
} as const;

export type PolicyRuleTypeRATELIMIT = typeof PolicyRuleTypeRATELIMIT[keyof typeof PolicyRuleTypeRATELIMIT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRuleTypeRATELIMIT = {
  rate_limit: 'rate_limit',
} as const;

export type PolicyRateLimit = typeof PolicyRateLimit[keyof typeof PolicyRateLimit];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRateLimit = {
  gas_per_transaction: 'gas_per_transaction',
  gas_per_interval: 'gas_per_interval',
  count_per_interval: 'count_per_interval',
} as const;

export interface GasPerTransactionLimitPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeRATELIMIT;
  functionName: PolicyRateLimitGASPERTRANSACTION;
  gasLimit: string;
}

export type PolicyRateLimitGASPERINTERVAL = typeof PolicyRateLimitGASPERINTERVAL[keyof typeof PolicyRateLimitGASPERINTERVAL];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRateLimitGASPERINTERVAL = {
  gas_per_interval: 'gas_per_interval',
} as const;

export type TimeIntervalType = typeof TimeIntervalType[keyof typeof TimeIntervalType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TimeIntervalType = {
  minute: 'minute',
  hour: 'hour',
  day: 'day',
  week: 'week',
  month: 'month',
} as const;

export interface GasPerIntervalLimitPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeRATELIMIT;
  functionName: PolicyRateLimitGASPERINTERVAL;
  gasLimit: string;
  timeIntervalType: TimeIntervalType;
  timeIntervalValue: number;
}

export type PolicyRateLimitCOUNTPERINTERVAL = typeof PolicyRateLimitCOUNTPERINTERVAL[keyof typeof PolicyRateLimitCOUNTPERINTERVAL];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRateLimitCOUNTPERINTERVAL = {
  count_per_interval: 'count_per_interval',
} as const;

export interface CountPerIntervalLimitPolicyRuleResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  createdAt: number;
  type: PolicyRuleTypeRATELIMIT;
  functionName: PolicyRateLimitCOUNTPERINTERVAL;
  countLimit: number;
  timeIntervalType: TimeIntervalType;
  timeIntervalValue: number;
}

export type PolicyRuleResponse = ContractPolicyRuleResponse | AccountPolicyRuleResponse | GasPerTransactionLimitPolicyRuleResponse | GasPerIntervalLimitPolicyRuleResponse | CountPerIntervalLimitPolicyRuleResponse;

export interface PolicyRuleListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: PolicyRuleResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 */
export type PolicyRuleListQueriesExpandItem = typeof PolicyRuleListQueriesExpandItem[keyof typeof PolicyRuleListQueriesExpandItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyRuleListQueriesExpandItem = {
  contract: 'contract',
} as const;

export interface PolicyRuleListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: PolicyRuleListQueriesExpandItem[];
  /** Specifies the unique policy ID (starts with pol_). */
  policy: string;
}

export interface CreatePolicyRuleRequest {
  /** The type of rule to add. */
  type: PolicyRuleType;
  /** Name of the function in the contract to allow. If you want to allow all functions, use the wildcard 'All functions'. */
  functionName?: string;
  /** The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`. */
  contract?: string;
  /** When using `contract_functions` type, set this to `true` to allow all contracts. */
  wildcard?: boolean;
  /** Gas limit in WEI (i.e. factor 10^18). */
  gasLimit?: string;
  /** Number of times the function will be sponsored. */
  countLimit?: number;
  /** Time interval between sponsorships. */
  timeIntervalType?: TimeIntervalType;
  /** Time interval value. */
  timeIntervalValue?: number;
  /** The unique Policy ID to add the rule to (starts with pol_). */
  policy: string;
}

export interface UpdatePolicyRuleRequest {
  /** The type of rule to add. */
  type: PolicyRuleType;
  /** Name of the function in the contract to allow. If you want to allow all functions, use the wildcard 'All functions'. */
  functionName?: string;
  /** The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`. */
  contract?: string;
  /** When using `contract_functions` type, set this to `true` to allow all contracts. */
  wildcard?: boolean;
  /** Gas limit in WEI (i.e. factor 10^18). */
  gasLimit?: string;
  /** Number of times the function will be sponsored. */
  countLimit?: number;
  /** Time interval between sponsorships. */
  timeIntervalType?: TimeIntervalType;
  /** Time interval value. */
  timeIntervalValue?: number;
}

export interface PolicyRuleDeleteResponse {
  id: string;
  object: EntityTypePOLICYRULE;
  deleted: boolean;
}

export type PolicyResponseTransactionIntentsItem = TransactionIntent | EntityIdResponse;

export type PolicyResponsePolicyRulesItem = PolicyRuleResponse | EntityIdResponse;

export interface PolicyResponse {
  id: string;
  object: EntityTypePOLICY;
  createdAt: number;
  /** @nullable */
  name: string | null;
  deleted: boolean;
  enabled: boolean;
  /** The chain ID. */
  chainId: number;
  paymaster?: EntityIdResponse;
  forwarderContract?: EntityIdResponse;
  strategy: PolicyStrategy;
  transactionIntents: PolicyResponseTransactionIntentsItem[];
  policyRules: PolicyResponsePolicyRulesItem[];
}

export interface PolicyListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: PolicyResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 */
export type PolicyResponseExpandable = typeof PolicyResponseExpandable[keyof typeof PolicyResponseExpandable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PolicyResponseExpandable = {
  transactionIntents: 'transactionIntents',
  policyRules: 'policyRules',
} as const;

export interface PolicyListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: PolicyResponseExpandable[];
  /** Specifies the name of the policy. */
  name?: string;
  /** Specifies whether to include deleted policies. */
  deleted?: boolean;
  /** The chain ID of the policy. */
  chainId?: number;
  /** Specifies whether to include enabled policies. */
  enabled?: boolean;
}

export interface PolicyStrategyRequest {
  /** The sponsor schema of the policy. */
  sponsorSchema: SponsorSchema;
  /** If the user pays in custom tokens, the contract ID (starts with con_) of the token contract. */
  tokenContract?: string;
  /** If the user pays in ERC20 tokens, this reflects either the exchange rate or the amount in WEI. */
  tokenContractAmount?: string;
  /** If the you want to use your own native tokens to pay for gas, specify the developer account ID (starts with dac_) */
  depositor?: string;
}

export interface CreatePolicyRequest {
  /** Specifies the name of the policy. */
  name: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** The sponsor schema of the policy. */
  strategy: PolicyStrategyRequest;
  /** The ID of the paymaster. */
  paymaster?: string;
  /** The ID of the forwarder contract. */
  forwarderContract?: string;
}

export interface UpdatePolicyRequest {
  /** Specifies the name of the policy. */
  name?: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** The sponsor schema of the policy. */
  strategy?: PolicyStrategyRequest;
  /** The ID of the paymaster. */
  paymaster?: string;
  /** The ID of the forwarder contract. */
  forwarderContract?: string;
  /** Specifies whether to delete the policy. */
  deleted?: boolean;
}

export interface PolicyDeleteResponse {
  id: string;
  object: EntityTypePOLICY;
  deleted: boolean;
}

export interface MonthRange {
  start: number;
  end: number;
}

export interface GasReportTransactionIntents {
  id: string;
  gasFee: string;
  gasPrice: string;
  gasUsed: string;
  gasFeeInUSD: string;
}

export interface GasReport {
  period: MonthRange;
  averageTransactionFee: string;
  totalTransactionFeeInCustomTokens: string;
  totalTransactionFee: string;
  totalTransactionFeeInUSD: string;
  /** @deprecated */
  transactionIntents: GasReportTransactionIntents[];
}

export interface GasReportListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: GasReport[];
  start: number;
  end: number;
  total: number;
}

export interface PolicyReportQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
}

export interface GasReportTransactionIntentsListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: GasReportTransactionIntents[];
  start: number;
  end: number;
  total: number;
}

export interface PolicyReportTransactionIntentsQueries {
  /** The start date of the period in unix timestamp. */
  to: number;
  /** The end date of the period in unix timestamp. */
  from: number;
}

export interface PolicyBalanceWithdrawResponse {
  policy: string;
  balance: string;
  contract: string;
}

export interface WithdrawalPolicyRequest {
  /** ID of the Dev Account this TransactionIntent will send the specified amount of tokens to (starts with `dac_`). */
  account: string;
  /** Amount in WEI to withdraw (i.e. factor 10^18).. */
  amount: string;
}

export type PlayerResponseTransactionIntentsItem = TransactionIntent | EntityIdResponse;

export type PlayerResponseAccountsItem = Account | EntityIdResponse;

export interface PlayerResponse {
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  name: string;
  description?: string;
  metadata?: PlayerMetadata;
  transactionIntents?: PlayerResponseTransactionIntentsItem[];
  accounts?: PlayerResponseAccountsItem[];
}

export interface PlayerListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: PlayerResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 */
export type PlayerResponseExpandable = typeof PlayerResponseExpandable[keyof typeof PlayerResponseExpandable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlayerResponseExpandable = {
  transactionIntents: 'transactionIntents',
  accounts: 'accounts',
} as const;

export interface PlayerListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the fields to expand in the response. */
  expand?: PlayerResponseExpandable[];
  /** Filter by player name. */
  name?: string;
}

export interface PlayerCreateRequest {
  /**
   * Specifies the player name.
   * @minLength 1
   * @maxLength 256
   */
  name?: string;
  /** Specifies the player description. */
  description?: string;
  /** Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata. */
  metadata?: PlayerMetadata;
}

export interface PlayerUpdateRequest {
  /**
   * Specifies the player name.
   * @minLength 1
   * @maxLength 256
   */
  name?: string;
  /** Specifies the player description. */
  description?: string;
  /** Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata. */
  metadata?: PlayerMetadata;
}

export interface PlayerDeleteResponse {
  id: string;
  object: EntityTypePLAYER;
  deleted: boolean;
}

export interface PlayerTransferOwnershipRequest {
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided. */
  policy: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** The address of the new owner */
  newOwnerAddress: string;
  /** ID of the Player that has the Account you want to transfer ownership from (starts with `pla_`). */
  player?: string;
}

export interface PlayerCancelTransferOwnershipRequest {
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided. */
  policy: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
}

export type EntityTypePAYMASTER = typeof EntityTypePAYMASTER[keyof typeof EntityTypePAYMASTER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypePAYMASTER = {
  paymaster: 'paymaster',
} as const;

export type PaymasterResponseContext = { [key: string]: unknown };

export interface PaymasterResponse {
  id: string;
  object: EntityTypePAYMASTER;
  createdAt: number;
  address: string;
  url?: string;
  context?: PaymasterResponseContext;
}

export type CreatePaymasterResponse = PaymasterResponse;

/**
 * Specifies the context, that is, the arbitrary repositories that the specific paymaster may require
 */
export type CreatePaymasterRequestContext = { [key: string]: unknown };

export interface CreatePaymasterRequest {
  /** Specifies the address of the paymaster */
  address: string;
  /** Specifies the paymaster URL */
  url?: string;
  /** Specifies the context, that is, the arbitrary repositories that the specific paymaster may require */
  context?: CreatePaymasterRequestContext;
  /** Specifies the name of the paymaster */
  name?: string;
}

export interface PagingQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
}

export interface PaymasterDeleteResponse {
  id: string;
  object: EntityTypePAYMASTER;
  deleted: boolean;
}

export type OnrampProvider = typeof OnrampProvider[keyof typeof OnrampProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OnrampProvider = {
  coinbase: 'coinbase',
  stripe: 'stripe',
} as const;

/**
 * Common fee structure for onramp operations
 */
export interface OnrampFee {
  type: string;
  amount: string;
  currency: string;
}

export type OnrampSessionResponseQuote = {
  exchangeRate?: string;
  fees?: OnrampFee[];
  destinationNetwork?: string;
  destinationCurrency?: string;
  destinationAmount?: string;
  sourceCurrency?: string;
  sourceAmount?: string;
};

/**
 * Common unified response format for creating an onramp session.
This format is provider-agnostic.
 */
export interface OnrampSessionResponse {
  provider: OnrampProvider;
  sessionId?: string;
  clientSecret?: string;
  status?: string;
  onrampUrl: string;
  redirectUrl?: string;
  quote?: OnrampSessionResponseQuote;
}

/**
 * Common unified request format for creating an onramp session.
This format is provider-agnostic and will be adapted by each provider service.
 */
export interface OnrampSessionRequest {
  provider: OnrampProvider;
  destinationCurrency: string;
  destinationNetwork: string;
  destinationAddress: string;
  sourceAmount?: string;
  sourceCurrency?: string;
  redirectUrl?: string;
  country?: string;
  subdivision?: string;
  paymentMethod?: string;
  clientIp?: string;
}

/**
 * Common unified response format for getting an onramp quote.
This format is provider-agnostic.
 */
export interface OnrampQuoteResponse {
  provider: OnrampProvider;
  sourceAmount: string;
  sourceCurrency: string;
  destinationAmount: string;
  destinationCurrency: string;
  destinationNetwork: string;
  fees: OnrampFee[];
  exchangeRate: string;
}

/**
 * Response type for quote requests that can return either a single quote or multiple quotes.
- Returns OnrampQuoteResponse when provider is specified
- Returns OnrampQuoteResponse[] when provider is not specified
 */
export type OnrampQuotesResponse = OnrampQuoteResponse | OnrampQuoteResponse[];

/**
 * Common unified request format for getting an onramp quote.
This format is provider-agnostic and will be adapted by each provider service.
If provider is specified, returns a single quote for that provider.
If provider is not specified, returns quotes from all available providers.
 */
export interface OnrampQuoteRequest {
  provider?: OnrampProvider;
  sourceCurrency: string;
  destinationCurrency: string;
  destinationNetwork: string;
  sourceAmount: string;
  paymentMethod?: string;
  country?: string;
  subdivision?: string;
}

export interface Log {
  id: string;
  timestamp: string;
  event: string;
  request_body: unknown;
  status: number;
  response_time: number;
  response_data: unknown;
}

export interface ProjectLogs {
  object: ResponseTypeLIST;
  url: string;
  data: Log[];
  start: number;
  end: number;
  total: number;
}

export type EntityTypeFORWARDERCONTRACT = typeof EntityTypeFORWARDERCONTRACT[keyof typeof EntityTypeFORWARDERCONTRACT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeFORWARDERCONTRACT = {
  forwarderContract: 'forwarderContract',
} as const;

export interface ForwarderContractResponse {
  id: string;
  object: EntityTypeFORWARDERCONTRACT;
  createdAt: number;
  address: string;
  chainId: number;
  name?: string;
}

export type CreateForwarderContractResponse = ForwarderContractResponse;

export interface CreateForwarderContractRequest {
  /** Specifies the address of the paymaster */
  address: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** Specifies the name of the paymaster */
  name?: string;
}

export interface ForwarderContractDeleteResponse {
  id: string;
  object: EntityTypeFORWARDERCONTRACT;
  deleted: boolean;
}

export type TradeType = typeof TradeType[keyof typeof TradeType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TradeType = {
  EXACT_INPUT: 'EXACT_INPUT',
  EXACT_OUTPUT: 'EXACT_OUTPUT',
} as const;

export interface CreateExchangeRequest {
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** The public address that will sign and submit the transaction. If you provide one of a `pla_...` or `acc_...` it will be converted to the corresponding address. */
  fromAddress: string;
  /** Token address or 'native' to sell */
  tokenInAddress: string;
  /** Token address or 'native' to buy */
  tokenOutAddress: string;
  /** Amount in the smallest unit of the token */
  amount: string;
  /** The type of trade, exact input or exact output */
  tradeType: TradeType;
  /** The percentage of slippage tolerance. Default = 0.1. Max = 50. Min = 0 */
  slippagePercent?: number;
  /** Maximum hops allowed in optimal route. Default is 2 */
  maxHops?: number;
  /** Latest time swap can execute. Default is 15 minutes */
  deadline?: number;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas. */
  policy?: string;
  /** Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain. */
  optimistic?: boolean;
}

/**
 * Type representing a token
 */
export interface Token {
  name?: string;
  symbol?: string;
  decimals: number;
  address: string;
  chainId: number;
}

/**
 * Interface representing a token amount
 */
export interface Amount {
  value: string;
  token: Token;
}

/**
 * Type representing the fees returned in the quote
 */
export interface Fee {
  amount: Amount;
  basisPoints: number;
  recipient: string;
}

export interface QuoteExchangeResult {
  amount: Amount;
  amountWithMaxSlippage: Amount;
  slippage: number;
  fees: Fee[];
  estimatedTXGasFee: string;
  estimatedTXGasFeeUSD: string;
  estimatedTXGasFeeToken?: string;
}

export type APITopicBALANCECONTRACT = typeof APITopicBALANCECONTRACT[keyof typeof APITopicBALANCECONTRACT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APITopicBALANCECONTRACT = {
  balancecontract: 'balance.contract',
} as const;

export type EntityTypeEVENT = typeof EntityTypeEVENT[keyof typeof EntityTypeEVENT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeEVENT = {
  event: 'event',
} as const;

export interface ContractEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicBALANCECONTRACT;
  threshold: string;
  contract: EntityIdResponse;
  functionName: string;
  functionArgs: string[];
}

export type APITopicBALANCEDEVACCOUNT = typeof APITopicBALANCEDEVACCOUNT[keyof typeof APITopicBALANCEDEVACCOUNT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APITopicBALANCEDEVACCOUNT = {
  balancedev_account: 'balance.dev_account',
} as const;

export interface AccountEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicBALANCEDEVACCOUNT;
  threshold: string;
  developerAccount: EntityIdResponse;
  chainId: number;
}

export type APITopicBALANCEPROJECT = typeof APITopicBALANCEPROJECT[keyof typeof APITopicBALANCEPROJECT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APITopicBALANCEPROJECT = {
  balanceproject: 'balance.project',
} as const;

export interface BalanceEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicBALANCEPROJECT;
  threshold: string;
}

export type APITopicTRANSACTIONSUCCESSFUL = typeof APITopicTRANSACTIONSUCCESSFUL[keyof typeof APITopicTRANSACTIONSUCCESSFUL];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APITopicTRANSACTIONSUCCESSFUL = {
  transaction_intentsuccessful: 'transaction_intent.successful',
} as const;

export interface TransactionConfirmedEventResponse {
  id: string;
  object: EntityTypeEVENT;
  createdAt: number;
  topic: APITopicTRANSACTIONSUCCESSFUL;
  numberOfBlocks: number;
}

export type EventResponse = ContractEventResponse | AccountEventResponse | BalanceEventResponse | TransactionConfirmedEventResponse;

export interface EventListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: EventResponse[];
  start: number;
  end: number;
  total: number;
}

export interface EventListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the name of the event */
  name?: string;
  /** Specifies if display deleted events */
  deleted?: boolean;
}

export type GetEventResponse = EventResponse;

export type CreateEventResponse = EventResponse;

export interface CreateEventRequest {
  /** Specifies the name of the event */
  name: string;
  /** Specifies the type of the event (transaction_intent.successful, balance.project, balance.contract, balance.dev_account) */
  topic: APITopic;
  /** Specifies the contract id (if the event is a contract event) */
  contract?: string;
  /** Specifies the function arguments (if the event is a contract event) */
  functionArgs?: string[];
  /** Specifies the function name (if the event is a contract event) */
  functionName?: string;
  /** Specifies the developer account id (if the event is a developer account event) */
  developerAccount?: string;
  /** Specifies the chain id (if the event is a developer account event) */
  chainId?: number;
  /** Threshold for the event (if the event is a contract, dev account or project event) */
  threshold?: string;
  /** Specifies the number of confirmations required for the event to trigger */
  numberOfBlocks?: number;
}

export interface EventDeleteResponse {
  id: string;
  object: EntityTypeEVENT;
  deleted: boolean;
}

export interface EmbeddedResponse {
  share: string;
  accountType: string;
  address: string;
  chainId: number;
  deviceId?: string;
}

export type EmbeddedNextActionResponseNextAction = typeof EmbeddedNextActionResponseNextAction[keyof typeof EmbeddedNextActionResponseNextAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmbeddedNextActionResponseNextAction = {
  RECOVER: 'RECOVER',
  REGISTER: 'REGISTER',
} as const;

export interface EmbeddedNextActionResponse {
  nextAction: EmbeddedNextActionResponseNextAction;
  player: string;
  embedded?: EmbeddedResponse;
}

export interface InitEmbeddedRequest {
  chainId: number;
}

export interface EmbeddedV2Response {
  share?: string;
  accountType: string;
  implementationType?: string;
  implementationAddress?: string;
  factoryAddress?: string;
  salt?: string;
  address: string;
  ownerAddress: string;
  chainType: string;
  chainId?: number;
  device?: string;
  account: string;
  signer: string;
}

export interface RegisterEmbeddedRequest {
  chainId: number;
  address: string;
  share: string;
  signerUuid?: string;
}

export interface SwitchChainRequest {
  chainId: number;
  deviceId: string;
}

export interface ExportedEmbeddedRequest {
  address: string;
}

export type EntityTypeDEVICE = typeof EntityTypeDEVICE[keyof typeof EntityTypeDEVICE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeDEVICE = {
  device: 'device',
} as const;

export interface DeviceResponse {
  id: string;
  object: EntityTypeDEVICE;
  createdAt: number;
  account: string;
  share: string;
  isPrimary: boolean;
}

export interface BaseEntityListResponseDeviceResponse {
  object: ResponseTypeLIST;
  url: string;
  data: DeviceResponse[];
  start: number;
  end: number;
  total: number;
}

export type DeviceListResponse = BaseEntityListResponseDeviceResponse;

export interface DeviceListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the unique account ID (starts with acc_) */
  account: string;
}

export type GetDeviceResponse = DeviceResponse;

export type CreateDeviceResponse = DeviceResponse;

export interface CreateDeviceRequest {
  /** Specifies the unique account ID (starts with acc_) */
  account: string;
  /** Specifies the share repositories */
  share: string;
}

export interface ContractListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: ContractResponse[];
  start: number;
  end: number;
  total: number;
}

export interface ContractListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the name of the contract. */
  name?: string;
  /** Specifies whether to include deleted contracts. */
  deleted?: boolean;
  /** The chain ID of the contract. */
  chainId?: number;
  /** Specifies the address of the contract. */
  address?: string;
}

export interface CreateContractRequest {
  /** Specifies the name of the contract (Only for display purposes). */
  name: string;
  /** Specifies the chain ID of the contract. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** Specifies the address of the contract. */
  address: string;
  /** Specifies the ABI of the contract. */
  abi?: Abi[];
  /** Specifies whether to verify the contract publicly. */
  publicVerification?: boolean;
}

export interface UpdateContractRequest {
  /** Specifies the name of the contract (Only for display purposes). */
  name?: string;
  /** Specifies the chain ID of the contract. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Specifies whether to delete the contract. */
  deleted?: boolean;
  /** Specifies the address of the contract. */
  address?: string;
  /** Specifies the ABI of the contract. */
  abi?: Abi[];
  /** Specifies whether to verify the contract publicly. */
  publicVerification?: boolean;
}

export type EntityTypeREADCONTRACT = typeof EntityTypeREADCONTRACT[keyof typeof EntityTypeREADCONTRACT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeREADCONTRACT = {
  readContract: 'readContract',
} as const;

export interface ContractReadResponse {
  id: string;
  object: EntityTypeREADCONTRACT;
  createdAt: number;
  functionName: string;
  result: unknown;
}

export interface ContractReadQueries {
  /** The function name of the contract. */
  functionName: string;
  /** The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs. */
  functionArgs?: unknown[];
}

export interface ContractDeleteResponse {
  id: string;
  object: EntityTypeCONTRACT;
  deleted: boolean;
}

export type AccountResponseTransactionIntentsItem = TransactionIntent | EntityIdResponse;

export type AccountResponsePlayer = EntityIdResponse | Player;

export interface AccountResponse {
  id: string;
  object: EntityTypeACCOUNT;
  createdAt: number;
  address: string;
  ownerAddress: string;
  deployed: boolean;
  custodial: boolean;
  embeddedSigner: boolean;
  /** The chain ID. */
  chainId: number;
  accountType: string;
  pendingOwnerAddress?: string;
  transactionIntents?: AccountResponseTransactionIntentsItem[];
  player: AccountResponsePlayer;
}

export interface AccountListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AccountResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 */
export type AccountResponseExpandable = typeof AccountResponseExpandable[keyof typeof AccountResponseExpandable];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountResponseExpandable = {
  player: 'player',
  transactionIntents: 'transactionIntents',
} as const;

export interface AccountListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Specifies the unique player ID (starts with pla_) */
  player?: string;
  /** Specifies the address of the account */
  address?: string;
  /** Specifies the fields to expand in the response. */
  expand?: AccountResponseExpandable[];
}

export interface CreateAccountRequest {
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
  /** Use this parameter to create a new Account for Player with the provided owner address. */
  externalOwnerAddress?: string;
  /** The type of smart account that will be created (e.g. UpgradeableV6, UpgradeableV5, ZKSyncUpgradeableV2). Defaults to UpgradeableV6. */
  accountType?: string;
  /** For account types that support social recovery, wether to enable Openfort as guardian or not. Defaults to false. */
  defaultGuardian?: boolean;
  /** ID of the player this account belongs to (starts with `pla_`). If none is provided, a new player will be created. */
  player?: string;
}

export interface TransferOwnershipRequest {
  /** The address of the new owner */
  newOwnerAddress: string;
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided. */
  policy: string;
}

export interface CancelTransferOwnershipRequest {
  /** ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided. */
  policy: string;
}

export interface DeployRequest {
  /** The policy ID (starts with pol_) */
  policy: string;
}

export interface StartRecoveryRequest {
  /** Address of the new owner */
  newOwnerAddress: string;
  /** The policy ID (starts with pol_) */
  policy: string;
}

export interface CompleteRecoveryRequest {
  /** Address of the new owner */
  newOwnerAddress: string;
  /** Signatures by the guardians */
  signatures?: string[];
  /** The policy ID (starts with pol_) */
  policy: string;
}

export type AuthProviderResponseV2 = typeof AuthProviderResponseV2[keyof typeof AuthProviderResponseV2];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthProviderResponseV2 = {
  credential: 'credential',
  email: 'email',
  wallet: 'wallet',
  google: 'google',
  apple: 'apple',
  twitter: 'twitter',
  discord: 'discord',
  facebook: 'facebook',
  custom: 'custom',
  oidc: 'oidc',
  siwe: 'siwe',
} as const;

export interface LinkedAccountResponseV2 {
  provider: AuthProviderResponseV2;
  createdAt: number;
  updatedAt: number;
  accountId?: string;
  chainType?: string;
  connectorType?: string;
  walletClientType?: string;
}

export interface AuthUserResponse {
  id: string;
  createdAt: number;
  name: string;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phoneNumber: string | null;
  phoneNumberVerified: boolean;
  isAnonymous?: boolean;
  linkedAccounts: LinkedAccountResponseV2[];
}

export interface BaseEntityListResponseAuthUserResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AuthUserResponse[];
  start: number;
  end: number;
  total: number;
}

export type UserListResponse = BaseEntityListResponseAuthUserResponse;

export interface UserListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Filter by user name. */
  name?: string;
  /** Filter by external user ID. */
  externalUserId?: string;
}

export interface BaseDeleteEntityResponseEntityTypePLAYER {
  id: string;
  object: EntityTypePLAYER;
  deleted: boolean;
}

export type UserDeleteResponse = BaseDeleteEntityResponseEntityTypePLAYER;

export interface SmartAccountData {
  implementationType: string;
  factoryAddress?: string;
  implementationAddress: string;
  salt?: string;
  deployedTx?: string;
  deployedAt?: number;
  active: boolean;
}

export interface PasskeyEnv {
  name?: string;
  os?: string;
  osVersion?: string;
  device?: string;
}

export interface RecoveryMethodDetails {
  passkeyId?: string;
  passkeyEnv?: PasskeyEnv;
}

export interface PregenerateAccountResponse {
  id: string;
  user: string;
  accountType: string;
  address: string;
  ownerAddress?: string;
  chainType: string;
  chainId?: number;
  createdAt: number;
  updatedAt: number;
  smartAccount?: SmartAccountData;
  recoveryMethod?: string;
  recoveryMethodDetails?: RecoveryMethodDetails;
  /** The recovery share for the user's embedded signer.
This should be stored securely and provided to the user for account recovery. */
  recoveryShare: string;
}

/**
 * Enum of the supporting third party auth providers.
 */
export type ThirdPartyOAuthProvider = typeof ThirdPartyOAuthProvider[keyof typeof ThirdPartyOAuthProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProvider = {
  accelbyte: 'accelbyte',
  firebase: 'firebase',
  lootlocker: 'lootlocker',
  playfab: 'playfab',
  supabase: 'supabase',
  custom: 'custom',
  oidc: 'oidc',
  'better-auth': 'better-auth',
} as const;

/**
 * The type of account to pregenerate. "Externally Owned Account", "Smart Account" or "Delegated Account".
Defaults to "Smart Account".
 */
export type PregenerateUserRequestV2AccountType = typeof PregenerateUserRequestV2AccountType[keyof typeof PregenerateUserRequestV2AccountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PregenerateUserRequestV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * The chain type. "EVM" or "SVM". Defaults to "EVM".
 */
export type PregenerateUserRequestV2ChainType = typeof PregenerateUserRequestV2ChainType[keyof typeof PregenerateUserRequestV2ChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PregenerateUserRequestV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export interface PregenerateUserRequestV2 {
  /** The email address of the user to pregenerate.
Required if thirdPartyUserId is not provided. */
  email?: string;
  /** The third-party user ID from an external auth provider (Firebase, Supabase, etc.).
Required if email is not provided. */
  thirdPartyUserId?: string;
  /** The third-party auth provider. Required when thirdPartyUserId is provided. */
  thirdPartyProvider?: ThirdPartyOAuthProvider;
  /** The type of account to pregenerate. "Externally Owned Account", "Smart Account" or "Delegated Account".
Defaults to "Smart Account". */
  accountType?: PregenerateUserRequestV2AccountType;
  /** The chain type. "EVM" or "SVM". Defaults to "EVM". */
  chainType?: PregenerateUserRequestV2ChainType;
  /** The chain ID. Required for Smart Account and Delegated Account types.
Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** The implementation type for Smart Account or Delegated Account (e.g. Calibur, UpgradeableV6).
Required for Smart Account and Delegated Account types. */
  implementationType?: string;
}

export interface RecoverV2Response {
  id: string;
  account: string;
  signerAddress: string;
  signer: string;
  share: string;
  isPrimary: boolean;
  createdAt: string;
  user: string;
}

export interface RecoverV2EmbeddedRequest {
  account: string;
}

export interface RegisterEmbeddedV2Request {
  account: string;
  share: string;
}

/**
 * The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account".
 */
export type CreateEmbeddedRequestAccountType = typeof CreateEmbeddedRequestAccountType[keyof typeof CreateEmbeddedRequestAccountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateEmbeddedRequestAccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * The chain type. "EVM" or "SVM".
 */
export type CreateEmbeddedRequestChainType = typeof CreateEmbeddedRequestChainType[keyof typeof CreateEmbeddedRequestChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateEmbeddedRequestChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export interface CreateEmbeddedRequest {
  /** The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account". */
  accountType: CreateEmbeddedRequestAccountType;
  /** The chain type. "EVM" or "SVM". */
  chainType: CreateEmbeddedRequestChainType;
  /** The wallet address. For EOA: the EOA address. For Smart Account: the owner address (EOA will be created with this address). For Delegated Account: the address for both EOA and Delegated Account. */
  address: string;
  /** The chain ID. Must be a [supported chain](/development/chains). Required for Smart Account and Delegated Account types. */
  chainId?: number;
  /** Specifies the share repositories. Required for creating embedded accounts. */
  share?: string;
  signerUuid?: string;
  /** The type of smart account that will be created (e.g. UpgradeableV6, UpgradeableV5, Calibur, Simple). Defaults to UpgradeableV6 in mainnets. Must support EIP-7702 for Delegated Accounts. */
  implementationType?: string;
}

/**
 * The type of object.
 */
export type BackendWalletResponseObject = typeof BackendWalletResponseObject[keyof typeof BackendWalletResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BackendWalletResponseObject = {
  backendWallet: 'backendWallet',
} as const;

/**
 * The chain type the wallet is associated with.
 */
export type BackendWalletResponseChainType = typeof BackendWalletResponseChainType[keyof typeof BackendWalletResponseChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BackendWalletResponseChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Backend wallet details response.
 */
export interface BackendWalletResponse {
  /**
   * The type of object.
   */
  object: BackendWalletResponseObject;
  /** The wallet ID (starts with `acc_`). */
  id: string;
  /** The wallet address. */
  address: string;
  /** The chain type the wallet is associated with. */
  chainType: BackendWalletResponseChainType;
  /** Optional name for the wallet. */
  name?: string;
  /** Creation timestamp (Unix epoch seconds). */
  createdAt: number;
  /** Last updated timestamp (Unix epoch seconds). */
  updatedAt: number;
}

/**
 * The type of object.
 */
export type BackendWalletListResponseObject = typeof BackendWalletListResponseObject[keyof typeof BackendWalletListResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BackendWalletListResponseObject = {
  list: 'list',
} as const;

/**
 * List of backend wallets response.
 */
export interface BackendWalletListResponse {
  /**
   * The type of object.
   */
  object: BackendWalletListResponseObject;
  /** API endpoint URL. */
  url: string;
  /** List of backend wallets. */
  data: BackendWalletResponse[];
  /** Starting index. */
  start: number;
  /** Ending index. */
  end: number;
  /** Total number of wallets. */
  total: number;
}

/**
 * Filter by chain type.
 */
export type BackendWalletListQueriesChainType = typeof BackendWalletListQueriesChainType[keyof typeof BackendWalletListQueriesChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BackendWalletListQueriesChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Query parameters for listing backend wallets.
 */
export interface BackendWalletListQueries {
  /** Number of wallets to return (default: 10, max: 100). */
  limit?: number;
  /** Number of wallets to skip (for pagination). */
  skip?: number;
  /** Filter by chain type. */
  chainType?: BackendWalletListQueriesChainType;
  /** Filter by wallet address. */
  address?: string;
  /** Filter by wallet name. */
  name?: string;
  /** Filter by associated wallet ID (starts with `pla_`). */
  wallet?: string;
}

/**
 * The type of object.
 */
export type CreateBackendWalletResponseObject = typeof CreateBackendWalletResponseObject[keyof typeof CreateBackendWalletResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateBackendWalletResponseObject = {
  account: 'account',
} as const;

/**
 * The chain type the wallet is associated with.
 */
export type CreateBackendWalletResponseChainType = typeof CreateBackendWalletResponseChainType[keyof typeof CreateBackendWalletResponseChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateBackendWalletResponseChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Response from creating a new backend wallet account.
 */
export interface CreateBackendWalletResponse {
  /**
   * The type of object.
   */
  object: CreateBackendWalletResponseObject;
  /** The created account ID (starts with `acc_`). */
  id: string;
  /** The wallet address generated for this account. */
  address: string;
  /** The chain type the wallet is associated with. */
  chainType: CreateBackendWalletResponseChainType;
  /** Creation timestamp (Unix epoch seconds). */
  createdAt: number;
}

/**
 * The chain type for the new wallet.
 */
export type CreateBackendWalletRequestChainType = typeof CreateBackendWalletRequestChainType[keyof typeof CreateBackendWalletRequestChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateBackendWalletRequestChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Request to create a new backend wallet account.
 */
export interface CreateBackendWalletRequest {
  /** The chain type for the new wallet. */
  chainType: CreateBackendWalletRequestChainType;
  /** The wallet ID to associate with this wallet (starts with `pla_`). */
  wallet?: string;
  /** Optional name for the wallet. */
  name?: string;
}

/**
 * The type of object.
 */
export type DeleteBackendWalletResponseObject = typeof DeleteBackendWalletResponseObject[keyof typeof DeleteBackendWalletResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeleteBackendWalletResponseObject = {
  backendWallet: 'backendWallet',
} as const;

/**
 * Response from deleting a backend wallet.
 */
export interface DeleteBackendWalletResponse {
  /**
   * The type of object.
   */
  object: DeleteBackendWalletResponseObject;
  /** The deleted wallet ID. */
  id: string;
  /** Whether the wallet was deleted. */
  deleted: boolean;
}

/**
 * The type of object.
 */
export type SignResponseObject = typeof SignResponseObject[keyof typeof SignResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SignResponseObject = {
  signature: 'signature',
} as const;

/**
 * Response from signing data via backend wallet.
 */
export interface SignResponse {
  /**
   * The type of object.
   */
  object: SignResponseObject;
  /** The account ID that signed the data (starts with `acc_`). */
  account: string;
  /** The signature bytes (hex-encoded). */
  signature: string;
}

/**
 * Request to sign data via backend wallet.
 */
export interface SignRequest {
  /** The data to sign (hex-encoded transaction data or message hash). */
  data: string;
}

/**
 * The type of object.
 */
export type ExportPrivateKeyResponseObject = typeof ExportPrivateKeyResponseObject[keyof typeof ExportPrivateKeyResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExportPrivateKeyResponseObject = {
  exportedKey: 'exportedKey',
} as const;

/**
 * Response from exporting a private key with E2E encryption.
 */
export interface ExportPrivateKeyResponse {
  /**
   * The type of object.
   */
  object: ExportPrivateKeyResponseObject;
  /** The private key encrypted with RSA-OAEP SHA-256 using your ephemeral public key (base64-encoded).
Decrypt using your ephemeral RSA private key. */
  encryptedPrivateKey: string;
}

/**
 * Request to export private key with E2E encryption.
 */
export interface ExportPrivateKeyRequest {
  /** Client's ephemeral RSA-4096 public key for end-to-end encryption (base64 SPKI DER format).
The backend wallet will encrypt the private key using RSA-OAEP SHA-256. */
  encryptionKey: string;
}

/**
 * The type of object.
 */
export type ImportPrivateKeyResponseObject = typeof ImportPrivateKeyResponseObject[keyof typeof ImportPrivateKeyResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportPrivateKeyResponseObject = {
  account: 'account',
} as const;

/**
 * The chain type the wallet is associated with.
 */
export type ImportPrivateKeyResponseChainType = typeof ImportPrivateKeyResponseChainType[keyof typeof ImportPrivateKeyResponseChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportPrivateKeyResponseChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Response from importing a private key with E2E encryption.
 */
export interface ImportPrivateKeyResponse {
  /**
   * The type of object.
   */
  object: ImportPrivateKeyResponseObject;
  /** The created account ID (starts with `acc_`). */
  id: string;
  /** The wallet address derived from the imported private key. */
  address: string;
  /** The chain type the wallet is associated with. */
  chainType?: ImportPrivateKeyResponseChainType;
  /** Creation timestamp (Unix epoch seconds). */
  createdAt: number;
}

/**
 * The chain type for the imported wallet.
 */
export type ImportPrivateKeyRequestChainType = typeof ImportPrivateKeyRequestChainType[keyof typeof ImportPrivateKeyRequestChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportPrivateKeyRequestChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Request to import private key with E2E encryption.
 */
export interface ImportPrivateKeyRequest {
  /** The private key encrypted with RSA-OAEP SHA-256 using the server's static import public key.
Obtain the server's import public key out-of-band (e.g., from SDK or documentation). */
  encryptedPrivateKey: string;
  /** The chain type for the imported wallet. */
  chainType?: ImportPrivateKeyRequestChainType;
  /** The wallet ID to associate with this wallet (starts with `pla_`). */
  wallet?: string;
  /** Optional name for the imported wallet. */
  name?: string;
}

/**
 * The type of object.
 */
export type RegisterWalletSecretResponseObject = typeof RegisterWalletSecretResponseObject[keyof typeof RegisterWalletSecretResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RegisterWalletSecretResponseObject = {
  walletSecret: 'walletSecret',
} as const;

/**
 * Response from registering a new wallet secret.
 */
export interface RegisterWalletSecretResponse {
  /**
   * The type of object.
   */
  object: RegisterWalletSecretResponseObject;
  /** The key ID for the registered secret. */
  keyId: string;
  /** Timestamp when the secret was registered (Unix epoch seconds). */
  registeredAt: number;
}

/**
 * Request to register a new wallet secret (authentication key).
 */
export interface RegisterWalletSecretRequest {
  /** ECDSA P-256 public key for wallet authentication (PEM or raw hex format).
This will be used to verify X-Wallet-Auth JWT signatures. */
  publicKey: string;
  /** Key identifier for the secret.
Used to identify this key in X-Wallet-Auth JWT headers. */
  keyId?: string;
}

/**
 * The type of object.
 */
export type RevokeWalletSecretResponseObject = typeof RevokeWalletSecretResponseObject[keyof typeof RevokeWalletSecretResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RevokeWalletSecretResponseObject = {
  walletSecretRevocation: 'walletSecretRevocation',
} as const;

/**
 * Response from revoking a wallet secret.
 */
export interface RevokeWalletSecretResponse {
  /**
   * The type of object.
   */
  object: RevokeWalletSecretResponseObject;
  /** The key ID of the revoked secret. */
  keyId: string;
  /** Whether the secret was successfully revoked. */
  revoked: boolean;
  /** Timestamp when the secret was revoked (Unix epoch seconds). */
  revokedAt: number;
}

/**
 * Request to revoke a wallet secret (authentication key).
 */
export interface RevokeWalletSecretRequest {
  /** Key identifier of the secret to revoke. */
  keyId: string;
}

/**
 * The type of object.
 */
export type RotateWalletSecretResponseObject = typeof RotateWalletSecretResponseObject[keyof typeof RotateWalletSecretResponseObject];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RotateWalletSecretResponseObject = {
  walletSecretRotation: 'walletSecretRotation',
} as const;

/**
 * Response from rotating a wallet secret.
 */
export interface RotateWalletSecretResponse {
  /**
   * The type of object.
   */
  object: RotateWalletSecretResponseObject;
  /** Whether the rotation was successful. */
  success: boolean;
  /** Timestamp when the rotation occurred (Unix epoch seconds). */
  rotatedAt: number;
}

/**
 * Request to rotate wallet secret (authentication key).
 */
export interface RotateWalletSecretRequest {
  /** New ECDSA P-256 public key for wallet authentication.
This will replace the current wallet secret used for X-Wallet-Auth JWT signing. */
  newSecretPublicKey: string;
  /** Key identifier for the new secret.
Used to identify this key in X-Wallet-Auth JWT headers. */
  newKeyId?: string;
}

export interface AccountV2Response {
  id: string;
  user: string;
  accountType: string;
  address: string;
  ownerAddress?: string;
  chainType: string;
  chainId?: number;
  createdAt: number;
  updatedAt: number;
  smartAccount?: SmartAccountData;
  recoveryMethod?: string;
  recoveryMethodDetails?: RecoveryMethodDetails;
}

export interface BaseEntityListResponseAccountV2Response {
  object: ResponseTypeLIST;
  url: string;
  data: AccountV2Response[];
  start: number;
  end: number;
  total: number;
}

export type AccountListV2Response = BaseEntityListResponseAccountV2Response;

/**
 * The chain type. Must be either "EVM" or "SVM".
 */
export type AccountListQueriesV2ChainType = typeof AccountListQueriesV2ChainType[keyof typeof AccountListQueriesV2ChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountListQueriesV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

/**
 * Specifies the type of account. Must be either "Smart Account" or "Externally Owned Account".
 */
export type AccountListQueriesV2AccountType = typeof AccountListQueriesV2AccountType[keyof typeof AccountListQueriesV2AccountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountListQueriesV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * Specifies the key custody of the account. Must be either "Developer" or "User".
 */
export type AccountListQueriesV2Custody = typeof AccountListQueriesV2Custody[keyof typeof AccountListQueriesV2Custody];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountListQueriesV2Custody = {
  Developer: 'Developer',
  User: 'User',
} as const;

export interface AccountListQueriesV2 {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Specifies the unique user ID (starts with pla_) */
  user?: string;
  /** The chain type. Must be either "EVM" or "SVM". */
  chainType?: AccountListQueriesV2ChainType;
  /** Specifies the type of account. Must be either "Smart Account" or "Externally Owned Account". */
  accountType?: AccountListQueriesV2AccountType;
  /** Specifies the key custody of the account. Must be either "Developer" or "User". */
  custody?: AccountListQueriesV2Custody;
  /** Specifies the account address */
  address?: string;
}

export interface SignerIdResponse {
  id: string;
}

export interface SwitchChainQueriesV2 {
  /** The account ID (starts with acc_) */
  account: string;
  /** The target chain ID. Must be a [supported chain](/development/chains). */
  chainId: number;
}

/**
 * The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account".
 */
export type CreateAccountRequestV2AccountType = typeof CreateAccountRequestV2AccountType[keyof typeof CreateAccountRequestV2AccountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateAccountRequestV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

/**
 * The chain type. "EVM" or "SVM".
 */
export type CreateAccountRequestV2ChainType = typeof CreateAccountRequestV2ChainType[keyof typeof CreateAccountRequestV2ChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateAccountRequestV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export interface CreateAccountRequestV2 {
  /** The type of smart account that will be created. "Externally Owned Account", "Smart Account" or "Delegated Account". */
  accountType: CreateAccountRequestV2AccountType;
  /** The chain type. "EVM" or "SVM". */
  chainType: CreateAccountRequestV2ChainType;
  address?: string;
  /** The type of smart account that will be created (e.g. UpgradeableV6, UpgradeableV5, Calibur). Defaults to UpgradeableV6 in mainnets. */
  implementationType?: string;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** ID of the user this account belongs to (starts with `pla_`). If none is provided, a new user will be created. */
  user: string;
  /** ID of the account (starts with `acc_`) to be linked with. Required for accountType "Smart Account". */
  account?: string;
}

export interface DeleteAccountResponse {
  id: string;
  object: EntityTypeACCOUNT;
  deleted: boolean;
}

export type UserProjectRole = typeof UserProjectRole[keyof typeof UserProjectRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserProjectRole = {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
} as const;

export type EntityTypeUSER = typeof EntityTypeUSER[keyof typeof EntityTypeUSER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeUSER = {
  user: 'user',
} as const;

export interface UserProjectResponse {
  id: string;
  object: EntityTypeUSER;
  createdAt: number;
  updatedAt: number;
  firstName: string;
  lastName: string;
  role: UserProjectRole;
  email: string;
}

export interface UserProjectListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: UserProjectResponse[];
  start: number;
  end: number;
  total: number;
}

export type UserProjectRoleADMIN = typeof UserProjectRoleADMIN[keyof typeof UserProjectRoleADMIN];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserProjectRoleADMIN = {
  ADMIN: 'ADMIN',
} as const;

export type UserProjectRoleMEMBER = typeof UserProjectRoleMEMBER[keyof typeof UserProjectRoleMEMBER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserProjectRoleMEMBER = {
  MEMBER: 'MEMBER',
} as const;

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserProjectCreateRequestRole = {...UserProjectRoleADMIN,...UserProjectRoleMEMBER,} as const
export interface UserProjectCreateRequest {
  /** The role of the user. */
  role?: typeof UserProjectCreateRequestRole[keyof typeof UserProjectCreateRequestRole] ;
  /** The email of the user to add. */
  email: string;
}

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserProjectUpdateRequestRole = {...UserProjectRoleMEMBER,...UserProjectRoleADMIN,} as const
export interface UserProjectUpdateRequest {
  /** The role of the user. */
  role: typeof UserProjectUpdateRequestRole[keyof typeof UserProjectUpdateRequestRole] ;
}

export interface UserProjectDeleteResponse {
  id: string;
  object: EntityTypeUSER;
  deleted: boolean;
}

export interface ApiKeyResponse {
  id: number;
  createdAt: number;
  token: string;
  name: string;
  livemode: boolean;
}

export interface WebhookResponse {
  /** @nullable */
  webhook: string | null;
  livemode: boolean;
}

export type EntityTypePROJECT = typeof EntityTypePROJECT[keyof typeof EntityTypePROJECT];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypePROJECT = {
  project: 'project',
} as const;

export interface ChildProjectResponse {
  id: string;
  object: EntityTypePROJECT;
  createdAt: number;
  name: string;
}

export interface ChildProjectListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: ChildProjectResponse[];
  start: number;
  end: number;
  total: number;
}

export interface ProjectResponse {
  id: string;
  object: EntityTypePROJECT;
  createdAt: number;
  updatedAt: number;
  name: string;
  apikeys?: ApiKeyResponse[];
  webhook?: WebhookResponse[];
  parentProject?: string;
  childProjects?: ChildProjectListResponse;
  isV2: boolean;
}

export interface ProjectListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: ProjectResponse[];
  start: number;
  end: number;
  total: number;
}

export interface TransactionStat {
  timestamp: string;
  total: number;
  successful: number;
  gasUsed: string;
}

export interface Stat {
  timestamp: string;
  total: number;
}

export type DeviceStat = Stat;

export interface ProjectStatsResponse {
  transactionIntents: TransactionStat[];
  devices: Stat[];
}

export type ProjectStatsRequestTimeFrame = typeof ProjectStatsRequestTimeFrame[keyof typeof ProjectStatsRequestTimeFrame];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProjectStatsRequestTimeFrame = {
  day: 'day',
  week: 'week',
  month: 'month',
  all: 'all',
} as const;

export interface ProjectStatsRequest {
  timeFrame: ProjectStatsRequestTimeFrame;
}

export type PlanChangeType = typeof PlanChangeType[keyof typeof PlanChangeType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlanChangeType = {
  upgrade: 'upgrade',
  downgrade: 'downgrade',
  none: 'none',
} as const;

export interface Plan {
  id: string;
  name: string;
  price: number;
  is_current: boolean;
  change_type: PlanChangeType;
  legacy?: boolean;
}

export interface PlansResponse {
  plans: Plan[];
}

export type BillingSubscriptionResponsePlan = {
  price: number;
  name: string;
  id: string;
};

export interface BillingSubscriptionResponse {
  currentPeriodEnd?: string;
  currentPeriodStart?: string;
  canceledAt?: string;
  plan: BillingSubscriptionResponsePlan;
}

export type PrivateKeyPolicy = typeof PrivateKeyPolicy[keyof typeof PrivateKeyPolicy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PrivateKeyPolicy = {
  INDIVIDUAL: 'INDIVIDUAL',
  PROJECT: 'PROJECT',
} as const;

export interface CreateProjectRequest {
  /**
   * Name of the project.
   * @minLength 1
   * @maxLength 256
   */
  name: string;
  /** The private key policyfor the project. */
  pkPolicy?: PrivateKeyPolicy;
}

export interface UpdateProjectRequest {
  /**
   * Name of the project.
   * @minLength 1
   * @maxLength 256
   */
  name: string;
}

export interface AllowedOriginsResponse {
  allowedOrigins: string[];
}

export interface AllowedOriginsRequest {
  allowedOrigins: string[];
}

export type EntityTypeSMTPCONFIG = typeof EntityTypeSMTPCONFIG[keyof typeof EntityTypeSMTPCONFIG];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeSMTPCONFIG = {
  smtpConfig: 'smtpConfig',
} as const;

export interface SMTPConfigResponse {
  user: string;
  pass: string;
  host: string;
  port: number;
  from: string;
  useSSL: boolean;
  object: EntityTypeSMTPCONFIG;
}

export type CreateSMTPConfigResponse = SMTPConfigResponse;

export interface UpsertSMTPConfigRequest {
  /** Specifies the user name */
  user?: string;
  /** Specifies the password */
  pass?: string;
  /** Specifies the host */
  host?: string;
  /** Specifies the from */
  from?: string;
  /** Specifies the port */
  port?: number;
  /** Specifies the use SSL */
  useSSL?: boolean;
}

export type GetSMTPConfigResponse = SMTPConfigResponse;

export interface DeleteSMTPConfigResponse {
  deleted: boolean;
  object: EntityTypeSMTPCONFIG;
}

export type EmailTypeResponse = typeof EmailTypeResponse[keyof typeof EmailTypeResponse];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailTypeResponse = {
  emailVerification: 'emailVerification',
  passwordReset: 'passwordReset',
} as const;

export type EntityTypeEMAILSAMPLE = typeof EntityTypeEMAILSAMPLE[keyof typeof EntityTypeEMAILSAMPLE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntityTypeEMAILSAMPLE = {
  emailSample: 'emailSample',
} as const;

export interface EmailSampleResponse {
  id: string;
  object: EntityTypeEMAILSAMPLE;
  createdAt: number;
  name: string;
  subject: string;
  body: string;
  type: EmailTypeResponse;
}

export type CreateEmailSampleResponse = EmailSampleResponse;

export type EmailTypeRequest = typeof EmailTypeRequest[keyof typeof EmailTypeRequest];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmailTypeRequest = {
  emailVerification: 'emailVerification',
  passwordReset: 'passwordReset',
} as const;

export interface CreateEmailSampleRequest {
  /** Specifies the name */
  name: string;
  /** Specifies the subject */
  subject: string;
  /** Specifies the body */
  body: string;
  /** Specifies the type */
  type: EmailTypeRequest;
}

export type GetEmailSampleResponse = EmailSampleResponse;

export interface BaseEntityListResponseEmailSampleResponse {
  object: ResponseTypeLIST;
  url: string;
  data: EmailSampleResponse[];
  start: number;
  end: number;
  total: number;
}

export type EmailSampleListResponse = BaseEntityListResponseEmailSampleResponse;

export interface EmailSampleDeleteResponse {
  deleted: boolean;
  id: string;
  object: EntityTypeEMAILSAMPLE;
}

export type UpdateEmailSampleResponse = EmailSampleResponse;

export interface UpdateEmailSampleRequest {
  /** Specifies the name */
  name?: string;
  /** Specifies the subject */
  subject?: string;
  /** Specifies the body */
  body?: string;
  /** Specifies the type */
  type?: EmailTypeRequest;
}

export interface EcosystemMetadata {[key: string]: string | number}

export interface EcosystemConfigurationResponse {
  /** Subdomain of the ecosystem. */
  customDomain: string;
  /** Primary color of the ecosystem. */
  primaryColor: string;
  /** Primary color foreground of the ecosystem. */
  primaryColorForeground: string;
  /** Radius of the ecosystem. */
  radius: string;
  /** Logo URL of the ecosystem. */
  logoUrl: string;
  /** Whitelisted frontend domains of the ecosystem. */
  ecosystemWalletDomains: string[];
  /** Terms of service URL */
  termsOfServiceUrl?: string;
  /** Privacy policy URL */
  privacyPolicyUrl?: string;
  /** Favicon URL */
  faviconUrl?: string;
  /** Examples of the ecosystem. */
  dashboardExamples?: EcosystemMetadata[];
  /** SDKs of the ecosystem. */
  dashboardSDKs?: EcosystemMetadata[];
  /** Support email of the ecosystem. */
  supportEmail?: string;
  /** Documentation URL of the ecosystem. */
  documentationUrl?: string;
}

export interface CreateEcosystemConfigurationRequest {
  /** Custom domain of the ecosystem. */
  customDomain: string;
  /** Primary color of the ecosystem. */
  primaryColor: string;
  /** Primary color foreground of the ecosystem. */
  primaryColorForeground: string;
  /** Radius of the ecosystem. */
  radius: string;
  /** Logo URL of the ecosystem. */
  logoUrl: string;
  /** URLs where the ecosystem wallet is hosted. */
  ecosystemWalletDomains?: string[];
  /** Terms of service URL */
  termsOfServiceUrl?: string;
  /** Privacy policy URL */
  privacyPolicyUrl?: string;
  /** Favicon URL */
  faviconUrl?: string;
  /** Examples of the ecosystem. */
  dashboardExamples?: EcosystemMetadata[];
  /** SDKs of the ecosystem. */
  dashboardSDKs?: EcosystemMetadata[];
  /** Support email of the ecosystem. */
  supportEmail?: string;
  /** Documentation URL of the ecosystem. */
  documentationUrl?: string;
}

export interface MyEcosystemResponse {
  publishableKey: string;
  name: string;
  configuration?: EcosystemConfigurationResponse;
}

export type ApiKeyType = typeof ApiKeyType[keyof typeof ApiKeyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiKeyType = {
  pk: 'pk',
  sk: 'sk',
  pk_shield: 'pk_shield',
  sk_shield: 'sk_shield',
} as const;

export interface CreateProjectApiKeyRequest {
  /** The type of the API key. */
  type: ApiKeyType;
}

export interface UpdateProjectApiKeyRequest {
  /** The type of the API key. */
  type: ApiKeyType;
  /** The API key to update. */
  uuid: string;
  /** Whether key to use to sign webhooks. */
  use_for_webhooks?: boolean;
}

export interface AuthorizedOriginsResponse {
  origins: string[];
}

export interface UpdateAuthorizedOriginsRequest {
  origins: string[];
}

export type AuthorizedNetworksResponseAuthorizedNetworksItem = {
  network: string;
  name: string;
};

export interface AuthorizedNetworksResponse {
  authorizedNetworks: AuthorizedNetworksResponseAuthorizedNetworksItem[];
}

export interface AuthorizedNetwork {
  name: string;
  network: string;
}

export interface UpdateAuthorizedNetworksRequest {
  authorizedNetworks: AuthorizedNetwork[];
}

export type AuthorizedAppsResponseAuthorizedAppsItem = {
  appUrlScheme?: string;
  appIdentifier: string;
  name: string;
};

export interface AuthorizedAppsResponse {
  authorizedApps: AuthorizedAppsResponseAuthorizedAppsItem[];
}

export interface AuthorizedApp {
  name: string;
  appIdentifier: string;
  appUrlScheme?: string;
}

export interface UpdateAuthorizedAppsRequest {
  authorizedApps: AuthorizedApp[];
}

export type AuthProviderResponse = typeof AuthProviderResponse[keyof typeof AuthProviderResponse];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthProviderResponse = {
  email: 'email',
  wallet: 'wallet',
  google: 'google',
  apple: 'apple',
  twitter: 'twitter',
  discord: 'discord',
  epic_games: 'epic_games',
  facebook: 'facebook',
  accelbyte: 'accelbyte',
  firebase: 'firebase',
  lootlocker: 'lootlocker',
  playfab: 'playfab',
  supabase: 'supabase',
  custom: 'custom',
  oidc: 'oidc',
} as const;

export interface LinkedAccountResponse {
  provider: AuthProviderResponse;
  email?: string;
  externalUserId?: string;
  connectorType?: string;
  walletClientType?: string;
  disabled: boolean;
  verified?: boolean;
  updatedAt?: number;
  address?: string;
  metadata?: PlayerMetadata;
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
export interface PickPlayerResponseId {
  id: string;
}

export type AuthPlayerResponsePlayer = PlayerResponse | PickPlayerResponseId;

export interface AuthPlayerResponse {
  player?: AuthPlayerResponsePlayer;
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  linkedAccounts: LinkedAccountResponse[];
}

export interface AuthResponse {
  /** Player's identifier. */
  player: AuthPlayerResponse;
  /** JWT access token. */
  token: string;
  /** Refresh token. */
  refreshToken: string;
}

export interface RefreshTokenRequest {
  /** Specifies the session refresh token. */
  refreshToken: string;
  /** Specifies whether to force refresh the session. */
  forceRefresh?: boolean;
}

export interface LogoutRequest {
  /** Specifies the refresh token. */
  refreshToken: string;
}

export interface SIWEInitResponse {
  /** The address of the player. */
  address: string;
  nonce: string;
  expiresAt: number;
}

export interface SIWERequest {
  /** The address of the user. */
  address: string;
}

export interface SIWEAuthenticateRequest {
  /** Signature of the EIP-712 message with the user's wallet. */
  signature: string;
  /** The EIP-712 message to sign. */
  message: string;
  /** The wallet client of the user */
  walletClientType: string;
  /** The connector type of the user */
  connectorType: string;
}

export type Actions = typeof Actions[keyof typeof Actions];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Actions = {
  verify_email: 'verify_email',
} as const;

export interface ActionRequiredResponse {
  action: Actions;
}

export interface SignupRequest {
  /** The email address of the player. */
  email: string;
  /** The password of the player. */
  password: string;
  /** The name of the player. */
  name?: string;
  /** The description of the player. */
  description?: string;
}

export interface LoginRequest {
  /** The email address of the user. */
  email: string;
  /** The password of the user. */
  password: string;
}

/**
 * The code verifier.
 */
export type CodeChallengeMethod = typeof CodeChallengeMethod[keyof typeof CodeChallengeMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CodeChallengeMethod = {
  plain: 'plain',
  S256: 'S256',
} as const;

export interface CodeChallenge {
  /** The code challenge. */
  codeChallenge: string;
  /** The code verifier. */
  method: CodeChallengeMethod;
}

export interface RequestVerifyEmailRequest {
  /** The email address of the user. */
  email: string;
  /** The URL sent to the user by email to reset the password. At the end of the URL, we will add the token in the format `?token=token`. */
  redirectUrl: string;
  /** The Code Challenge if you want to use PKCE. */
  challenge?: CodeChallenge;
}

export interface CodeChallengeVerify {
  /** The code verifier. */
  codeVerifier: string;
}

export interface VerifyEmailRequest {
  /** The email address of the user. */
  email: string;
  /** Unique value to identify the request. Obtained from the email. */
  token: string;
  /** The Code Challenge to verify the PKCE if you used it in the request. */
  challenge?: CodeChallengeVerify;
}

export interface RequestResetPasswordRequest {
  /** The email address of the user. */
  email: string;
  /** The URL sent to the user by email to reset the password. At the end of the URL, we will add the token in the format `?token=token`. */
  redirectUrl: string;
  /** The Code Challenge if you want to use PKCE. */
  challenge?: CodeChallenge;
}

export interface ResetPasswordRequest {
  /** The email address of the user. */
  email: string;
  /** The new password of the user. */
  password: string;
  /** Unique value to identify the request. It's used to mitigate CSRF attacks. */
  state?: string;
  /** The Code Challenge to verify the PKCE if you used it in the request. */
  challenge?: CodeChallengeVerify;
}

export interface UnlinkEmailRequest {
  /** The email address of the user. */
  email: string;
}

export interface LoginOIDCRequest {
  /** The identity token of the user. */
  identityToken: string;
}

export interface OAuthResponse {
  url: string;
  key: string;
}

/**
 * Enum of the supporting OAuth providers.
 */
export type OAuthProvider = typeof OAuthProvider[keyof typeof OAuthProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProvider = {
  google: 'google',
  twitter: 'twitter',
  facebook: 'facebook',
  discord: 'discord',
  epic_games: 'epic_games',
  line: 'line',
  apple: 'apple',
} as const;

/**
 * An object of query params
 */
export type OAuthInitRequestOptionsQueryParams = {[key: string]: string};

export type OAuthInitRequestOptions = {
  /** A URL to custom handle the provider callback */
  callbackTo?: string;
  /** An object of query params */
  queryParams?: OAuthInitRequestOptionsQueryParams;
  /** A URL to send the user to after they are confirmed. */
  redirectTo?: string;
};

export interface OAuthInitRequest {
  options?: OAuthInitRequestOptions;
  /** Use Pooling for the OAuth flow

This option is for the flow that requires the user can't be redirected from the authorization page to the application.
The client should poll the server to check if the user has authorized the application. */
  usePooling?: boolean;
  /** One of the providers supported by Openfort */
  provider: OAuthProvider;
}

export interface ThirdPartyLinkRequest {
  provider: ThirdPartyOAuthProvider;
  token: string;
  tokenType: string;
}

export interface LoginWithIdTokenRequest {
  /** OAuth provider */
  provider: OAuthProvider;
  /** Token to be verified */
  token: string;
}

/**
 * Enum of the supporting OAuth providers.
 */
export type TokenType = typeof TokenType[keyof typeof TokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenType = {
  idToken: 'idToken',
  customToken: 'customToken',
} as const;

export interface ThirdPartyOAuthRequest {
  /** OAuth provider */
  provider: ThirdPartyOAuthProvider;
  /** Token to be verified */
  token: string;
  tokenType?: TokenType;
}

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticateOAuthRequestProvider = {...OAuthProvider,...ThirdPartyOAuthProvider,} as const
export interface AuthenticateOAuthRequest {
  /** OAuth provider */
  provider: typeof AuthenticateOAuthRequestProvider[keyof typeof AuthenticateOAuthRequestProvider] ;
  /** Token to be verified */
  token: string;
  /** Type of the token. */
  tokenType: TokenType;
  /** Specifies the fields to expand in the response. */
  expand?: PlayerResponseExpandable[];
}

/**
 * The request to verify access token
 */
export interface UnlinkOAuthRequest {
  /** The provider type being linked */
  provider: OAuthProvider;
}

export type BasicAuthProviderEMAIL = typeof BasicAuthProviderEMAIL[keyof typeof BasicAuthProviderEMAIL];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BasicAuthProviderEMAIL = {
  email: 'email',
} as const;

/**
 * Enum of the supporting Basic Auth providers.
 */
export type BasicAuthProvider = typeof BasicAuthProvider[keyof typeof BasicAuthProvider];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BasicAuthProvider = {
  email: 'email',
  wallet: 'wallet',
  guest: 'guest',
  web3: 'web3',
  phone: 'phone',
} as const;

/**
 * Enum of the supporting Auth providers.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthProvider = {...OAuthProvider,...ThirdPartyOAuthProvider,...BasicAuthProvider,} as const
export type AuthProvider = typeof AuthProvider[keyof typeof AuthProvider] ;

/**
 * Password requirements configuration
 */
export type EmailAuthConfigPasswordRequirements = {
  /** Require at least one special character (default: false) */
  requireSpecialChar?: boolean;
  /** Require at least one number (default: false) */
  requireNumber?: boolean;
  /** Require at least one lowercase letter (default: false) */
  requireLowercase?: boolean;
  /** Require at least one uppercase letter (default: false) */
  requireUppercase?: boolean;
  /** Minimum password length (default: 6) */
  minLength: number;
};

/**
 * Email auth configuration
 */
export interface EmailAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderEMAIL;
  /** Allow unverified emails: Users will be able to sign in with unverified emails */
  allowUnverified: boolean;
  /** Length of the OTP code (default: 6) */
  otpLength: number;
  /** Password requirements configuration */
  passwordRequirements: EmailAuthConfigPasswordRequirements;
}

export type BasicAuthProviderGUEST = typeof BasicAuthProviderGUEST[keyof typeof BasicAuthProviderGUEST];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BasicAuthProviderGUEST = {
  guest: 'guest',
} as const;

export interface GuestAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderGUEST;
}

export type BasicAuthProviderWEB3 = typeof BasicAuthProviderWEB3[keyof typeof BasicAuthProviderWEB3];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BasicAuthProviderWEB3 = {
  web3: 'web3',
} as const;

export interface Web3AuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderWEB3;
}

export type BasicAuthProviderPHONE = typeof BasicAuthProviderPHONE[keyof typeof BasicAuthProviderPHONE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BasicAuthProviderPHONE = {
  phone: 'phone',
} as const;

export type SmsProviderTWILIO = typeof SmsProviderTWILIO[keyof typeof SmsProviderTWILIO];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SmsProviderTWILIO = {
  twilio: 'twilio',
} as const;

/**
 * Twilio SMS provider configuration
 */
export interface TwilioSmsProviderConfig {
  provider: SmsProviderTWILIO;
  /** Twilio Account SID */
  accountSid: string;
  /** Twilio Auth Token */
  authToken: string;
  /** Twilio phone number (from) */
  phoneNumber: string;
}

export type SmsProviderMESSAGEBIRD = typeof SmsProviderMESSAGEBIRD[keyof typeof SmsProviderMESSAGEBIRD];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SmsProviderMESSAGEBIRD = {
  messagebird: 'messagebird',
} as const;

/**
 * MessageBird SMS provider configuration
 */
export interface MessageBirdSmsProviderConfig {
  provider: SmsProviderMESSAGEBIRD;
  /** MessageBird Access Key */
  accessKey: string;
  /** Sender name or number */
  originator: string;
}

export type SmsProviderTXTLOCAL = typeof SmsProviderTXTLOCAL[keyof typeof SmsProviderTXTLOCAL];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SmsProviderTXTLOCAL = {
  txtlocal: 'txtlocal',
} as const;

/**
 * TxtLocal SMS provider configuration
 */
export interface TxtLocalSmsProviderConfig {
  provider: SmsProviderTXTLOCAL;
  /** TxtLocal API Key */
  apiKey: string;
  /** Sender name */
  sender: string;
}

export type SmsProviderVONAGE = typeof SmsProviderVONAGE[keyof typeof SmsProviderVONAGE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SmsProviderVONAGE = {
  vonage: 'vonage',
} as const;

/**
 * Vonage SMS provider configuration
 */
export interface VonageSmsProviderConfig {
  provider: SmsProviderVONAGE;
  /** Vonage API Key */
  apiKey: string;
  /** Vonage API Secret */
  apiSecret: string;
  /** Sender ID or phone number */
  from: string;
}

export type SmsProviderSMSAPI = typeof SmsProviderSMSAPI[keyof typeof SmsProviderSMSAPI];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SmsProviderSMSAPI = {
  sms_api: 'sms_api',
} as const;

/**
 * SMS API provider configuration
 */
export interface SmsApiProviderConfig {
  provider: SmsProviderSMSAPI;
  /** Sender name */
  from: string;
  /** SMSAPI OAuth token */
  token: string;
}

/**
 * SMS provider configuration
 */
export type PhoneAuthConfigSmsProviderConfig = TwilioSmsProviderConfig | MessageBirdSmsProviderConfig | TxtLocalSmsProviderConfig | VonageSmsProviderConfig | SmsApiProviderConfig;

/**
 * Phone auth configuration
 */
export interface PhoneAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** Auth provider type */
  provider: BasicAuthProviderPHONE;
  /** SMS provider configuration */
  smsProviderConfig: PhoneAuthConfigSmsProviderConfig;
  /** SMS message template. Use {{ .Code }} to format the OTP code (default: "Your code is {{ .Code }}") */
  smsTemplate: string;
}

export type ThirdPartyOAuthProviderSUPABASE = typeof ThirdPartyOAuthProviderSUPABASE[keyof typeof ThirdPartyOAuthProviderSUPABASE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderSUPABASE = {
  supabase: 'supabase',
} as const;

/**
 * Supabase oauth configuration
 */
export interface SupabaseAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderSUPABASE;
  /** The unique Supabase URL which is supplied when you create a new project in your project dashboard. */
  url: string;
  /** The unique Supabase Key which is supplied when you create a new project in your project dashboard. */
  key: string;
}

export type ThirdPartyOAuthProviderOIDC = typeof ThirdPartyOAuthProviderOIDC[keyof typeof ThirdPartyOAuthProviderOIDC];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderOIDC = {
  oidc: 'oidc',
} as const;

export interface OIDCAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderOIDC;
  /** PEM encoded public key to verify the JWT token */
  publicVerificationKey?: string;
  /** Audience of the JWT token */
  aud: string;
  /** JWKS URL to fetch the public key */
  jwksUrl?: string;
}

export type ThirdPartyOAuthProviderACCELBYTE = typeof ThirdPartyOAuthProviderACCELBYTE[keyof typeof ThirdPartyOAuthProviderACCELBYTE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderACCELBYTE = {
  accelbyte: 'accelbyte',
} as const;

/**
 * Accelbyte oauth configuration
 */
export interface AccelbyteOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderACCELBYTE;
  /** Base URI of your accelbyte gaming service environment. E.g. https://mygame.dev.gamingservices.accelbyte.io/ */
  baseUrl: string;
  /** Client ID of your accelbyte gaming service environment. */
  clientId: string;
  /** Secret of your confidential IAM client. */
  clientSecret: string;
}

export type OAuthProviderGOOGLE = typeof OAuthProviderGOOGLE[keyof typeof OAuthProviderGOOGLE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProviderGOOGLE = {
  google: 'google',
} as const;

/**
 * Google oauth configuration
 */
export interface GoogleOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderGOOGLE;
  /** Google API client ID. */
  clientId: string;
  /** Google API client secret. */
  clientSecret?: string;
}

export type OAuthProviderTWITTER = typeof OAuthProviderTWITTER[keyof typeof OAuthProviderTWITTER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProviderTWITTER = {
  twitter: 'twitter',
} as const;

/**
 * Twitter oauth configuration
 */
export interface TwitterOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderTWITTER;
  /** Twitter API consumer key. */
  clientId: string;
  /** Twitter API consumer secret. */
  clientSecret: string;
}

export type OAuthProviderFACEBOOK = typeof OAuthProviderFACEBOOK[keyof typeof OAuthProviderFACEBOOK];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProviderFACEBOOK = {
  facebook: 'facebook',
} as const;

export interface FacebookOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderFACEBOOK;
  /** Facebook API client ID. */
  clientId: string;
  /** Facebook API client secret. */
  clientSecret: string;
}

export type OAuthProviderAPPLE = typeof OAuthProviderAPPLE[keyof typeof OAuthProviderAPPLE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProviderAPPLE = {
  apple: 'apple',
} as const;

export interface AppleOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderAPPLE;
  /** Apple API client ID (Service ID). */
  clientId: string;
  /** Pre-generated client secret JWT */
  clientSecret?: string;
}

export type OAuthProviderLINE = typeof OAuthProviderLINE[keyof typeof OAuthProviderLINE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProviderLINE = {
  line: 'line',
} as const;

export interface LineOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderLINE;
  /** Line Channel ID. */
  channelId: string;
  /** Line Channel secret. */
  channelSecret: string;
}

export type OAuthProviderDISCORD = typeof OAuthProviderDISCORD[keyof typeof OAuthProviderDISCORD];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProviderDISCORD = {
  discord: 'discord',
} as const;

export interface DiscordOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderDISCORD;
  /** Discord API client ID. */
  clientId: string;
  /** Discord API client secret. */
  clientSecret: string;
}

export type OAuthProviderEPICGAMES = typeof OAuthProviderEPICGAMES[keyof typeof OAuthProviderEPICGAMES];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthProviderEPICGAMES = {
  epic_games: 'epic_games',
} as const;

export interface EpicGamesOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: OAuthProviderEPICGAMES;
  /** Epic Games API client ID. */
  clientId: string;
  /** Epic Games API client secret. */
  clientSecret: string;
}

export type ThirdPartyOAuthProviderPLAYFAB = typeof ThirdPartyOAuthProviderPLAYFAB[keyof typeof ThirdPartyOAuthProviderPLAYFAB];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderPLAYFAB = {
  playfab: 'playfab',
} as const;

/**
 * PlayFab oauth configuration
 */
export interface PlayFabOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderPLAYFAB;
  /** Title ID of your Play Fab gaming service environment. */
  titleId: string;
}

export type ThirdPartyOAuthProviderFIREBASE = typeof ThirdPartyOAuthProviderFIREBASE[keyof typeof ThirdPartyOAuthProviderFIREBASE];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderFIREBASE = {
  firebase: 'firebase',
} as const;

/**
 * Firebase configuration
 */
export interface FirebaseOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderFIREBASE;
  /** Project ID of your Firebase service environment. */
  projectId: string;
}

export type ThirdPartyOAuthProviderCUSTOM = typeof ThirdPartyOAuthProviderCUSTOM[keyof typeof ThirdPartyOAuthProviderCUSTOM];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderCUSTOM = {
  custom: 'custom',
} as const;

export interface CustomAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderCUSTOM;
  /** Headers to send with the request */
  headers?: string;
  /** URL to send the request to to verify the payload */
  authenticationUrl: string;
}

export type ThirdPartyOAuthProviderLOOTLOCKER = typeof ThirdPartyOAuthProviderLOOTLOCKER[keyof typeof ThirdPartyOAuthProviderLOOTLOCKER];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderLOOTLOCKER = {
  lootlocker: 'lootlocker',
} as const;

/**
 * LootLocker oauth configuration
 */
export interface LootLockerOAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderLOOTLOCKER;
}

export type ThirdPartyOAuthProviderBETTERAUTH = typeof ThirdPartyOAuthProviderBETTERAUTH[keyof typeof ThirdPartyOAuthProviderBETTERAUTH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ThirdPartyOAuthProviderBETTERAUTH = {
  'better-auth': 'better-auth',
} as const;

/**
 * Better Auth configuration
 */
export interface BetterAuthConfig {
  /** Enable OAuth provider. */
  enabled: boolean;
  /** OAuth provider type */
  provider: ThirdPartyOAuthProviderBETTERAUTH;
  /** Base URL of the Better Auth instance. E.g. https://your-app.com/api/auth */
  baseUrl: string;
}

export type AuthConfig = EmailAuthConfig | GuestAuthConfig | Web3AuthConfig | PhoneAuthConfig | SupabaseAuthConfig | OIDCAuthConfig | AccelbyteOAuthConfig | GoogleOAuthConfig | TwitterOAuthConfig | FacebookOAuthConfig | AppleOAuthConfig | LineOAuthConfig | DiscordOAuthConfig | EpicGamesOAuthConfig | PlayFabOAuthConfig | FirebaseOAuthConfig | CustomAuthConfig | LootLockerOAuthConfig | BetterAuthConfig;

/**
 * Response for the OAuth config list method.
 */
export interface OAuthConfigListResponse {
  /** List of the OAuth providers configurations */
  data: AuthConfig[];
}

export interface GrantOAuthResponse {
  authorizationCode?: string;
  accessToken?: string;
  refreshToken?: string;
  playerId?: string;
}

export interface GrantCallbackRequest {
  code: string;
  state: string;
}

/**
 * OAuth provider specific configuration.
 */
export type OAuthConfigResponse = AuthConfig;

/**
 * Request for the configuration endpoints for the OAuth providers
 */
export type OAuthConfigRequest = AuthConfig;

export type AuthMigrationStatus = typeof AuthMigrationStatus[keyof typeof AuthMigrationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthMigrationStatus = {
  created: 'created',
  running: 'running',
  paused: 'paused',
  completed: 'completed',
  failed: 'failed',
  canceled: 'canceled',
} as const;

/**
 * Mapping strategy for the migration. This is used to transform the ids between the source and destination providers.
For the transformation, the order of the operations is:
1. Trim the prefix and suffix from the destination id.
2. Add the prefix and suffix to the destination id.
When a user is authenticated in the destination provider, the id is transformed using the mapping strategy to find if exists in the source provider.
If the id is not found, the user is created in the destination provider.
If the id is found, the user in the destination provider is linked to the source provider.
 */
export interface MappingStrategy {
  /** Prefix to trim from the destination id. */
  trimPrefix?: string;
  /** Suffix to trim from the destination id. */
  trimSuffix?: string;
  /** Prefix to add to the destination id. */
  addPrefix?: string;
  /** Suffix to add to the destination id. */
  addSuffix?: string;
}

/**
 * Auth Migration Response.
 */
export interface AuthMigrationResponse {
  /** Unique identifier for the migration. */
  id: string;
  /** The source provider for the migration. */
  sourceProvider: AuthProvider;
  /** The destination provider for the migration. */
  destinationProvider: AuthProvider;
  /** The status of the migration. */
  status: AuthMigrationStatus;
  /** The created date of the migration. */
  createdAt: string;
  /** If the migration is finished, this will be the date it was finished. */
  finishedAt?: string;
  /** The mapping strategy used for the migration.
If not provided, the direct mapping will be used. */
  mappingStrategy?: MappingStrategy;
}

/**
 * Request for migrating authentication from one provider to another
 */
export interface CreateMigrationRequest {
  /** The mapping strategy used for the migration.
If not provided, the direct mapping will be used. */
  mappingStrategy?: MappingStrategy;
  /** Destination provider */
  destinationProvider: AuthProvider;
  /** Source provider */
  sourceProvider: AuthProvider;
}

export interface AuthMigrationListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AuthMigrationResponse[];
  start: number;
  end: number;
  total: number;
}

/**
 * Request for listing Migrations
 */
export interface ListMigrationsRequest {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Source provider */
  sourceProvider?: AuthProvider;
  /** Destination provider */
  destinationProvider?: AuthProvider;
  /** Status of the migration */
  status?: AuthMigrationStatus[];
}

/**
 * Request for update the status of a migration
 */
export interface UpdateMigrationRequest {
  /** The mapping strategy used for the migration.
If not provided, the direct mapping will be used. */
  mappingStrategy?: MappingStrategy;
  /** Status of the migration */
  status: AuthMigrationStatus;
}

export type AuthenticationType = typeof AuthenticationType[keyof typeof AuthenticationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationType = {
  oauth: 'oauth',
  basic: 'basic',
  third_party: 'third_party',
} as const;

export interface AuthProviderWithTypeResponse {
  type: AuthenticationType;
  provider: AuthProvider;
}

export interface AuthProviderListResponse {
  data: AuthProviderWithTypeResponse[];
}

export interface ListConfigRequest {
  enabled?: boolean;
}

export type AuthPlayerResponseWithRecoverySharePlayer = PlayerResponse | PickPlayerResponseId;

export interface AuthPlayerResponseWithRecoveryShare {
  player?: AuthPlayerResponseWithRecoverySharePlayer;
  id: string;
  object: EntityTypePLAYER;
  createdAt: number;
  linkedAccounts: LinkedAccountResponse[];
  recoveryShare?: string;
}

export interface CreateAuthPlayerRequest {
  /** The third party user id. */
  thirdPartyUserId: string;
  /** The third party provider. */
  thirdPartyProvider: ThirdPartyOAuthProvider;
  /** Pre generate embedded account. */
  preGenerateEmbeddedAccount: boolean;
  /** The chain ID. Must be a [supported chain](/development/chains). */
  chainId?: number;
  /** Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to metadata. */
  metadata?: PlayerMetadata;
}

export interface AuthPlayerListResponse {
  object: ResponseTypeLIST;
  url: string;
  data: AuthPlayerResponse[];
  start: number;
  end: number;
  total: number;
}

export interface AuthPlayerListQueries {
  /**
   * Specifies the maximum number of records to return.
   * @minimum 1
   */
  limit?: number;
  /**
   * Specifies the offset for the first records to return.
   * @minimum 0
   */
  skip?: number;
  /** Specifies the order in which to sort the results. */
  order?: PrismaSortOrder;
  /** Specifies the email address of the user. */
  email?: string;
  /** Specifies the external user ID. */
  externalUserId?: string;
}

export interface AuthSessionResponse {
  livemode: boolean;
  projectId: string;
  playerId: string;
  issuer: string;
  issuedAt: number;
  expiration: number;
  sessionId: string;
}

export interface JwtKey {
  kty: string;
  x: string;
  y: string;
  crv: string;
  kid: string;
  use: string;
  alg: string;
}

export interface JwtKeyResponse {
  keys: JwtKey[];
}

export interface AuthenticatedPlayerResponse {
  /** Player's identifier. */
  player: AuthPlayerResponse;
}

export interface AuthorizePlayerRequest {
  /** The authorization code received from the api to authorize the project to use the Ecosystem player. */
  authorizationCode: string;
}

export type GetTransactionIntentsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: TransactionIntentResponseExpandable[];
/**
 * The chain ID. Must be a [supported chain](/development/chains).
 */
chainId?: number;
/**
 * Filter by account ID or developer account (starts with acc_ or dac_ respectively).
 */
account?: string[];
/**
 * Filter by player ID (starts with pla_).
 */
player?: string[];
/**
 * Filter by successful (1) or failed (0) transaction intents.
 */
status?: number;
/**
 * Filter by policy ID (starts with pol_).
 */
policy?: string[];
};

export type GetTransactionIntentParams = {
/**
 * Specifies the expandable fields.
 */
expand?: TransactionIntentResponseExpandable[];
};

export type ListSubscriptionLogsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the topic of the subscription logs
 */
topic?: APITopic;
/**
 * Specifies the status of the subscription logs
 */
status?: Status;
/**
 * Specifies the object ID of the object related to triggered notification
 */
object?: string;
/**
 * Specifies the subscription ID
 */
subscription?: string;
/**
 * Specifies the trigger ID
 */
trigger?: string;
/**
 * Specifies the request ID
 */
requestID?: string;
};

export type TestTrigger200 = {
  sent: boolean;
};

export type GetDeveloperAccountsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: DeveloperAccountResponseExpandable[];
/**
 * Specifies whether to include deleted dev accounts.
 */
deleted?: boolean;
};

export type GetDeveloperAccountParams = {
expand?: DeveloperAccountResponseExpandable[];
};

export type GetVerificationPayloadParams = {
/**
 * Specifies the address
 */
address: string;
};

export type GetPlayerSessionsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * The player ID (starts with pla_)
 */
player: string;
/**
 * Specifies the fields to expand in the response.
 */
expand?: SessionResponseExpandable[];
};

export type GetSessionParams = {
/**
 * Specifies the fields to expand.
 */
expand?: SessionResponseExpandable[];
};

export type GetPolicyRulesParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: GetPolicyRulesExpandItem[];
/**
 * Specifies the unique policy ID (starts with pol_).
 */
policy: string;
};

/**
 */
export type GetPolicyRulesExpandItem = typeof GetPolicyRulesExpandItem[keyof typeof GetPolicyRulesExpandItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetPolicyRulesExpandItem = {
  contract: 'contract',
} as const;

export type GetPoliciesParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: PolicyResponseExpandable[];
/**
 * Specifies the name of the policy.
 */
name?: string;
/**
 * Specifies whether to include deleted policies.
 */
deleted?: boolean;
/**
 * The chain ID of the policy.
 */
chainId?: number;
/**
 * Specifies whether to include enabled policies.
 */
enabled?: boolean;
};

export type GetPolicyParams = {
/**
 * Specifies the fields to expand.
 */
expand?: PolicyResponseExpandable[];
};

export type GetPolicyTotalGasUsageParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
};

export type GetPolicyReportTransactionIntentsParams = {
/**
 * The start date of the period in unix timestamp.
 */
to: number;
/**
 * The end date of the period in unix timestamp.
 */
from: number;
};

export type GetPlayersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the fields to expand in the response.
 */
expand?: PlayerResponseExpandable[];
/**
 * Filter by player name.
 */
name?: string;
};

export type GetPlayerParams = {
/**
 * Specifies the expandable fields.
 */
expand?: PlayerResponseExpandable[];
};

export type ListPaymastersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
};

export type ListForwarderContractsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
};

export type GetEventsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the name of the event
 */
name?: string;
/**
 * Specifies if display deleted events
 */
deleted?: boolean;
};

export type GetContractsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the name of the contract.
 */
name?: string;
/**
 * Specifies whether to include deleted contracts.
 */
deleted?: boolean;
/**
 * The chain ID of the contract.
 */
chainId?: number;
/**
 * Specifies the address of the contract.
 */
address?: string;
};

export type ReadContractParams = {
/**
 * The function name of the contract.
 */
functionName: string;
/**
 * The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs.
 */
functionArgs?: unknown[];
};

export type GetAccountsParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * The chain ID. Must be a [supported chain](/development/chains).
 */
chainId?: number;
/**
 * Specifies the unique player ID (starts with pla_)
 */
player?: string;
/**
 * Specifies the address of the account
 */
address?: string;
/**
 * Specifies the fields to expand in the response.
 */
expand?: AccountResponseExpandable[];
};

export type GetAccountParams = {
expand?: AccountResponseExpandable[];
};

export type GetAuthUsersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Filter by user name.
 */
name?: string;
/**
 * Filter by external user ID.
 */
externalUserId?: string;
};

export type ListBackendWalletsParams = {
/**
 * Number of wallets to return (default: 10, max: 100).
 */
limit?: number;
/**
 * Number of wallets to skip (for pagination).
 */
skip?: number;
/**
 * Filter by chain type.
 */
chainType?: ListBackendWalletsChainType;
/**
 * Filter by wallet address.
 */
address?: string;
/**
 * Filter by wallet name.
 */
name?: string;
/**
 * Filter by associated wallet ID (starts with `pla_`).
 */
wallet?: string;
};

export type ListBackendWalletsChainType = typeof ListBackendWalletsChainType[keyof typeof ListBackendWalletsChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ListBackendWalletsChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export type GetAccountsV2Params = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * The chain ID. Must be a [supported chain](/development/chains).
 */
chainId?: number;
/**
 * Specifies the unique user ID (starts with pla_)
 */
user?: string;
/**
 * The chain type. Must be either "EVM" or "SVM".
 */
chainType?: GetAccountsV2ChainType;
/**
 * Specifies the type of account. Must be either "Smart Account" or "Externally Owned Account".
 */
accountType?: GetAccountsV2AccountType;
/**
 * Specifies the key custody of the account. Must be either "Developer" or "User".
 */
custody?: GetAccountsV2Custody;
/**
 * Specifies the account address
 */
address?: string;
};

export type GetAccountsV2ChainType = typeof GetAccountsV2ChainType[keyof typeof GetAccountsV2ChainType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAccountsV2ChainType = {
  EVM: 'EVM',
  SVM: 'SVM',
} as const;

export type GetAccountsV2AccountType = typeof GetAccountsV2AccountType[keyof typeof GetAccountsV2AccountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAccountsV2AccountType = {
  Externally_Owned_Account: 'Externally Owned Account',
  Smart_Account: 'Smart Account',
  Delegated_Account: 'Delegated Account',
} as const;

export type GetAccountsV2Custody = typeof GetAccountsV2Custody[keyof typeof GetAccountsV2Custody];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAccountsV2Custody = {
  Developer: 'Developer',
  User: 'User',
} as const;

export type GetSignerIdByAddressParams = {
address: string;
};

export type SignupEmailPassword201 = AuthResponse | ActionRequiredResponse;

export type LoginEmailPassword200 = AuthResponse | ActionRequiredResponse;

export type LinkEmail200 = AuthPlayerResponse | ActionRequiredResponse;

export type PoolOAuthParams = {
key: string;
};

export type ListParams = {
enabled?: boolean;
};

export type GetAuthPlayersParams = {
/**
 * Specifies the maximum number of records to return.
 * @minimum 1
 */
limit?: number;
/**
 * Specifies the offset for the first records to return.
 * @minimum 0
 */
skip?: number;
/**
 * Specifies the order in which to sort the results.
 */
order?: PrismaSortOrder;
/**
 * Specifies the email address of the user.
 */
email?: string;
/**
 * Specifies the external user ID.
 */
externalUserId?: string;
};

export type VerifyAuthTokenParams = {
/**
 * Specifies the auth token.
 */
token: string;
};

export type Authorize200 = AuthPlayerResponse | AuthenticatedPlayerResponse;

